<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Supertux-devel] dev version bug
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/supertux-devel/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:supertux-devel%40lists.berlios.de?Subject=Re%3A%20%5BSupertux-devel%5D%20dev%20version%20bug&In-Reply-To=%3C445420A9.4040300%40a-king.us%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000182.html">
   <LINK REL="Next"  HREF="000187.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Supertux-devel] dev version bug</H1>
    <B>Allen King</B> 
    <A HREF="mailto:supertux-devel%40lists.berlios.de?Subject=Re%3A%20%5BSupertux-devel%5D%20dev%20version%20bug&In-Reply-To=%3C445420A9.4040300%40a-king.us%3E"
       TITLE="[Supertux-devel] dev version bug">allen at a-king.us
       </A><BR>
    <I>Sun Apr 30 04:27:53 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000182.html">[Supertux-devel] dev version bug
</A></li>
        <LI>Next message: <A HREF="000187.html">[Supertux-devel] dev version bug
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#183">[ date ]</a>
              <a href="thread.html#183">[ thread ]</a>
              <a href="subject.html#183">[ subject ]</a>
              <a href="author.html#183">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Joth,

   Thanks for getting back to me so quickly, and with all the right data.

There may have been a mis-understanding. The experiment I'm asking you 
to do is not to fix your problem, but to produce additional output in 
the failing mode that will help me isolate another suspected related 
problem.  (Below, I will tell you how to get the code to work, but not 
here.)

So here are some points I want to make very clear. (Sorry if this is 
obvious, and I'm being blunt.):

   1. The newer version of the RandomGenerator::srand method code I sent
      you also fail.  I want it to.  As such, that line 72 of
      random_generator.cpp (the &quot;*assert(0);*&quot;) fails is not a problem
      for this test, it is good.
   2. Line 68 should be of a form &quot;*if (x &lt; RAND_MAX)*&quot; to duplicate the
      failure.  In particular, it should not be modified to &quot;*if (x &lt;=
      RAND_MAX)*&quot;, or the failure may change or perhaps go away. 
      ACTION: change line 68 from &quot;*&lt;=*&quot; back to &quot;*&lt;*&quot;, so the failure
      will be replicated.
   3. I see no line like &quot;*==== srand(ddd) (ddd) RAND_MAX=xxx =====*&quot;
      (where ddd (xxx) are some decimal (hex) numbers) in your console
      output.  QUESTION: Double and tripple check. Did you perhaps not
      compile the changes, or not use the patched version when making
      the new console output? 
   4. If the above gets you lines like &quot;*=====....*&quot; above in the
      console output, you're done, send be back the console and
      random_generator.cpp, and ignore this.  If still no such lines
      appear, I'm wondering if your console log is only monitoring
      things to standard error.  To get these printouts also on standard
      error, try changing the string &quot;*printf(*&quot; to &quot;*fprintf(stderr,
      *&quot;, in lines 67 and 71.  (You may or may not need to add a
      &quot;*#include &lt;stdio.h&gt;*&quot; line to compile properly.) At this point,
      the routine in question should look like the following: 

*#include &lt;stdio.h&gt;
int RandomGenerator::srand(int x)    {
    int x0 = x;
    while (x == 0)                          // random seed of zero means
        x = time(0);                        // randomize with time
    fprintf(stderr, &quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, 
x0, RAND_MAX);
    if (x &lt; RAND_MAX) {
    }
    else {                                  // only allow posative 
31-bit seeds
        fprintf(stderr, &quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0, 
RAND_MAX);
        assert(0);
    }
    RandomGenerator::srandom(x);
    return x;                               // let caller know seed used
}

*When you get the line with the &quot;*====...*&quot; in it, send me back the same 
stuff as before, except don't bother with the config file -- it's good.

If you can't get the &quot;*====...*&quot; line, try commenting out the assert(0) 
above, and replace the following routine:

*int RandomGenerator::rand(int v) {
    assert(v != 0 &amp;&amp; v &lt;= RAND_MAX);
    int rv = **RandomGenerator::random();
 **   printf(&quot;===x= rand(%10d) (%10d) RAND_MAX=%x =x====\n&quot;, v, rv, 
RAND_MAX);
**    fprintf(stderr, &quot;==== rand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, v, 
rv, RAND_MAX);
**    return rv % v;
}
*
Short of that, can I have VNC  access to your machine?  Hopefully it 
won't get to that!

    Allen

P.S.:  To run supertux, use the origional code (without any of the mods 
I've been feeding to you for debug), and comment out the 
&quot;*assert(x&lt;RAND_MAX);*&quot; line.

Joth Esmo wrote:
&gt;<i> I replaced the text in the .cpp file as you asked and compiled. The
</I>&gt;<i> error log (stderr) is attached. Line 72 of random_generator.cpp seems
</I>&gt;<i> to be the problem (the line being: assert(0);). Also attached is my
</I>&gt;<i> ./supertux/config file. I start the application by opening MSYS,
</I>&gt;<i> navigating to my supertux directory, and issuing the command
</I>&gt;<i> 'supertux.exe -w' (as per the Building on Windows page on the wiki --
</I>&gt;<i> however the -w has been recently removed).
</I>&gt;<i>
</I>&gt;<i> In your email, you asked for the patched version of random_seed.cpp. I
</I>&gt;<i> assume you meant random_generator.cpp, which is attached.
</I>&gt;<i>
</I>&gt;<i> I'm not sure what you mean by 'capable of debug'. Should I debug it
</I>&gt;<i> and then watch the value of the config variable? I didn't quite
</I>&gt;<i> understand your meaning.
</I>&gt;<i>
</I>&gt;<i> PS&gt; I changed the text in random_generator.cpp to read : x &lt;= RAND_MAX
</I>&gt;<i> (as you requested).
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Joth
</I>&gt;<i>
</I>&gt;<i> On 4/29/06, Allen King &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/supertux-devel">allen at a-king.us</A>&gt; wrote:
</I>&gt;&gt;<i> Joth,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A new patch to fix that problem is in the works, and should be in svn
</I>&gt;&gt;<i> shortly.  Should have been x &lt;= RAND_MAX. For the moment, that line 
</I>&gt;&gt;<i> can be
</I>&gt;&gt;<i> commented out, or the &lt; changed to &lt;= .
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> But the fact that this problem happened at all is curious to me, and I
</I>&gt;&gt;<i> suspect another bug lurking nearby.  In particular, I would like to
</I>&gt;&gt;<i> understand what about your XP setup caused that assertion error.  If
</I>&gt;&gt;<i> RAND_MAX is 0x7fffffff, the largest int32, it would be improbably that
</I>&gt;&gt;<i> time(0) would generate that (unless it's not working).  Or perhaps 
</I>&gt;&gt;<i> RAND_MAX
</I>&gt;&gt;<i> is smaller.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you can patch to the source code, would you replace the routine in
</I>&gt;&gt;<i> random_generator.cpp with
</I>&gt;&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;&gt;<i>     int x0 = x;
</I>&gt;&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;&gt;<i>     printf(&quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, x0, 
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>     if (x &lt; RAND_MAX) {
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     else {                                  // only allow posative 
</I>&gt;&gt;<i> 31-bit
</I>&gt;&gt;<i> seeds
</I>&gt;&gt;<i>         printf(&quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0, RAND_MAX);
</I>&gt;&gt;<i>         assert(0);
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;&gt;<i>     return x;                               // let caller
</I>&gt;&gt;<i> know seed used
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i> and recreate the failure.  Send me the command line used to invoke 
</I>&gt;&gt;<i> supertux,
</I>&gt;&gt;<i> the failing printout (as you did), a copy of your ~/.supertux/config 
</I>&gt;&gt;<i> file,
</I>&gt;&gt;<i> and the patched copy of random_seed.cpp.  If you are you capable of 
</I>&gt;&gt;<i> debug,
</I>&gt;&gt;<i> the variable config-&gt;random_seed should be traced.  Is it RAND_MAX at 
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> assertion failure?  Who sets it that?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks for your help on this.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>        Allen
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Jonathan Campbell wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Greetings I just finished compiling the development version of 
</I>&gt;&gt;<i> SuperTux (the
</I>&gt;&gt;<i> newest build) and tried to launch it. However, it quits after showing a
</I>&gt;&gt;<i> transparent window. The file stderr has the following: [INFO]
</I>&gt;&gt;<i> src/main.cpp:195 [C:\Documents and
</I>&gt;&gt;<i> Settings\Administrator\.supertux] is in the search path
</I>&gt;&gt;<i> [INFO] src/main.cpp:195 [c:\msys\1.0\build\supertux\/data]
</I>&gt;&gt;<i> is in the search path [INFO] src/main.cpp:429 Component 'controller'
</I>&gt;&gt;<i> finished after 0.2 seconds [INFO] src/main.cpp:68 Couldn't load 
</I>&gt;&gt;<i> config file:
</I>&gt;&gt;<i> Couldn't open file 'config': The system cannot find the file 
</I>&gt;&gt;<i> specified. ,
</I>&gt;&gt;<i> using default settings [INFO] src/main.cpp:429 Component 'config' 
</I>&gt;&gt;<i> finished
</I>&gt;&gt;<i> after 0 seconds [INFO] src/main.cpp:429 Component 'tinygettext' finished
</I>&gt;&gt;<i> after 0.001 seconds [INFO] src/main.cpp:429 Component 'commandline' 
</I>&gt;&gt;<i> finished
</I>&gt;&gt;<i> after 0 seconds [INFO] src/main.cpp:429 Component 'audio' finished after
</I>&gt;&gt;<i> 0.202 seconds [INFO] src/main.cpp:429 Component 'video' finished 
</I>&gt;&gt;<i> after 0.278
</I>&gt;&gt;<i> seconds [INFO] src/main.cpp:429 Component 'scripting' finished after 
</I>&gt;&gt;<i> 0.005
</I>&gt;&gt;<i> seconds [DEBUG] src/tile_manager.cpp:47 Tiles loaded in 0.059 seconds 
</I>&gt;&gt;<i> [INFO]
</I>&gt;&gt;<i> src/main.cpp:429 Component 'resources' finished after 0.236 seconds
</I>&gt;&gt;<i> Assertion failed: x &lt; RAND_MAX, file src/random_generator.cpp, line 
</I>&gt;&gt;<i> 57 I'm
</I>&gt;&gt;<i> running Windows XP with all updates installed. To compile it, I 
</I>&gt;&gt;<i> followed the
</I>&gt;&gt;<i> instructions on this page on the wiki:
</I>&gt;&gt;<i> <A HREF="http://supertux.berlios.de/wiki/index.php/Building_on_Windows">http://supertux.berlios.de/wiki/index.php/Building_on_Windows</A>
</I>&gt;&gt;<i> Any help would be appreciated. I'd really like to see this new 
</I>&gt;&gt;<i> version of
</I>&gt;&gt;<i> SuperTux. Regards, Joth Esmo
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Supertux-devel mailing list <A HREF="https://lists.berlios.de/mailman/listinfo/supertux-devel">Supertux-devel at lists.berlios.de</A>
</I>&gt;&gt;<i> <A HREF="http://lists.berlios.de/mailman/listinfo/supertux-devel">http://lists.berlios.de/mailman/listinfo/supertux-devel</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -- 
</I>&gt;<i> Flarbland: Your one and only stop for cheats, articles, comedy and
</I>&gt;<i> much, much more!
</I>&gt;<i> <A HREF="http://flarbland.bravehost.com">http://flarbland.bravehost.com</A>
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> [INFO] src/main.cpp:195 [C:\Documents and Settings\HP_Administrator\.supertux] is in the search path
</I>&gt;<i> [INFO] src/main.cpp:195 [c:\msys\1.0\build\supertux2\/data] is in the search path
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'controller' finished after 0.2 seconds
</I>&gt;<i> [WARNING] src/control/joystickkeyboardcontroller.cpp:192 Invalid button '0' in buttonmap
</I>&gt;<i> [WARNING] src/control/joystickkeyboardcontroller.cpp:192 Invalid button '1' in buttonmap
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'config' finished after 0.021 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'tinygettext' finished after 0 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'commandline' finished after 0 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'audio' finished after 0.302 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'video' finished after 0.432 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'scripting' finished after 0.034 seconds
</I>&gt;<i> [DEBUG] src/tile_manager.cpp:47 Tiles loaded in 0.057 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'resources' finished after 0.217 seconds
</I>&gt;<i> Assertion failed: 0, file src/random_generator.cpp, line 72
</I>&gt;<i>
</I>&gt;<i> This application has requested the Runtime to terminate it in an unusual way.
</I>&gt;<i> Please contact the application's support team for more information.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> (supertux-config
</I>&gt;<i>   (show_fps #f)
</I>&gt;<i>   (cheats #f)
</I>&gt;<i>   (video
</I>&gt;<i>     (fullscreen #t)
</I>&gt;<i>     (width 800)
</I>&gt;<i>     (height 600)
</I>&gt;<i>   )
</I>&gt;<i>   (audio
</I>&gt;<i>     (sound_enabled #t)
</I>&gt;<i>     (music_enabled #t)
</I>&gt;<i>   )
</I>&gt;<i>   (control
</I>&gt;<i>     (keymap
</I>&gt;<i>       (map
</I>&gt;<i>         (key 13)
</I>&gt;<i>         (control &quot;menu-select&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 19)
</I>&gt;<i>         (control &quot;pause-menu&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 27)
</I>&gt;<i>         (control &quot;pause-menu&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 94)
</I>&gt;<i>         (control &quot;console&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 112)
</I>&gt;<i>         (control &quot;pause-menu&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 271)
</I>&gt;<i>         (control &quot;menu-select&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 273)
</I>&gt;<i>         (control &quot;jump&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 274)
</I>&gt;<i>         (control &quot;down&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 275)
</I>&gt;<i>         (control &quot;right&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 276)
</I>&gt;<i>         (control &quot;left&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 303)
</I>&gt;<i>         (control &quot;up&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (key 304)
</I>&gt;<i>         (control &quot;action&quot;)
</I>&gt;<i>       )
</I>&gt;<i>     )
</I>&gt;<i>     (joystick
</I>&gt;<i>       (use_hat #t)
</I>&gt;<i>       (axis_x 0)
</I>&gt;<i>       (axis_y 1)
</I>&gt;<i>       (dead_zone_x 1000)
</I>&gt;<i>       (dead_zone_y 1000)
</I>&gt;<i>       (map
</I>&gt;<i>         (button 0)
</I>&gt;<i>         (control &quot;jump&quot;)
</I>&gt;<i>       )
</I>&gt;<i>       (map
</I>&gt;<i>         (button 1)
</I>&gt;<i>         (control &quot;action&quot;)
</I>&gt;<i>       )
</I>&gt;<i>     )
</I>&gt;<i>   )
</I>&gt;<i> )
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> // $Id: random_generator.cpp 3435 2006-04-26 02:13:42Z sik0fewl $
</I>&gt;<i> // 
</I>&gt;<i> // A strong random number generator
</I>&gt;<i> //
</I>&gt;<i> // Copyright (C) 2006 Allen King
</I>&gt;<i> // Copyright (C) 2002 Michael Ringgaard. All rights reserved.
</I>&gt;<i> // Copyright (C) 1983, 1993 The Regents of the University of California.
</I>&gt;<i> //
</I>&gt;<i> // Redistribution and use in source and binary forms, with or without
</I>&gt;<i> // modification, are permitted provided that the following conditions
</I>&gt;<i> // are met:
</I>&gt;<i> // 
</I>&gt;<i> // 1. Redistributions of source code must retain the above copyright 
</I>&gt;<i> //    notice, this list of conditions and the following disclaimer.  
</I>&gt;<i> // 2. Redistributions in binary form must reproduce the above copyright
</I>&gt;<i> //    notice, this list of conditions and the following disclaimer in the
</I>&gt;<i> //    documentation and/or other materials provided with the distribution.  
</I>&gt;<i> // 3. Neither the name of the project nor the names of its contributors
</I>&gt;<i> //    may be used to endorse or promote products derived from this software
</I>&gt;<i> //    without specific prior written permission. 
</I>&gt;<i> // 
</I>&gt;<i> // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</I>&gt;<i> // ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
</I>&gt;<i> // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
</I>&gt;<i> // ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
</I>&gt;<i> // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</I>&gt;<i> // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</I>&gt;<i> // OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</I>&gt;<i> // HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
</I>&gt;<i> // LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
</I>&gt;<i> // OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
</I>&gt;<i> // SUCH DAMAGE.
</I>&gt;<i>
</I>&gt;<i> // Transliterated into C++ Allen King 060417, from sources on
</I>&gt;<i> //          <A HREF="http://www.jbox.dk/sanos/source/lib/random.c.html">http://www.jbox.dk/sanos/source/lib/random.c.html</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> #include &lt;stdexcept&gt;
</I>&gt;<i> #include &quot;random_generator.hpp&quot;
</I>&gt;<i> #include &quot;scripting/squirrel_util.hpp&quot;
</I>&gt;<i>
</I>&gt;<i> RandomGenerator systemRandom;               // global random number generator
</I>&gt;<i>
</I>&gt;<i> RandomGenerator::RandomGenerator() {
</I>&gt;<i>     assert(sizeof(int) &gt;= 4);
</I>&gt;<i>     initialized = 0;
</I>&gt;<i>     initialize();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> RandomGenerator::~RandomGenerator() {
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> /*int RandomGenerator::srand(int x)    {
</I>&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;<i>     assert(x &lt; RAND_MAX);                   // only allow posative 31-bit seeds
</I>&gt;<i>     assert(sizeof(int) &gt;= 4);
</I>&gt;<i>     srandom(x);
</I>&gt;<i>     return x;                               // let caller know seed used
</I>&gt;<i> }*/
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;<i>     int x0 = x;
</I>&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;<i>     printf(&quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, x0, RAND_MAX);
</I>&gt;<i>     if (x &lt;= RAND_MAX) {
</I>&gt;<i>     }
</I>&gt;<i>     else {                                  // only allow posative 31-bit seeds
</I>&gt;<i>         printf(&quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0, RAND_MAX);
</I>&gt;<i>         assert(0);
</I>&gt;<i>     }
</I>&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;<i>     return x;                               // let caller know seed used
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand()                 {        return random();    }
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand(int v) {
</I>&gt;<i>     assert(v != 0 &amp;&amp; v &lt;= RAND_MAX);        // illegal arg: 0 or too big
</I>&gt;<i>     return RandomGenerator::random() % v;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand(int u, int v) {
</I>&gt;<i>     assert(v &gt; u);    
</I>&gt;<i>     return u + RandomGenerator::rand(v-u);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> double RandomGenerator::randf(double v) {
</I>&gt;<i>     float rv;
</I>&gt;<i>     while ((rv = (double)RandomGenerator::random() / RAND_MAX * v) &gt;= v)
</I>&gt;<i>         ;                                   // never return v!
</I>&gt;<i>     return rv;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> double RandomGenerator::randf(double u, double v) {
</I>&gt;<i>     return u + RandomGenerator::randf(v-u);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //-----------------------------------------------------------------------
</I>&gt;<i> //        
</I>&gt;<i> // Copyright (C) 2002 Michael Ringgaard. All rights reserved.
</I>&gt;<i> // Copyright (C) 1983, 1993 The Regents of the University of California.
</I>&gt;<i> //
</I>&gt;<i> // Redistribution and use in source and binary forms, with or without
</I>&gt;<i> // modification, are permitted provided that the following conditions
</I>&gt;<i> // are met:
</I>&gt;<i> // 
</I>&gt;<i> // 1. Redistributions of source code must retain the above copyright 
</I>&gt;<i> //    notice, this list of conditions and the following disclaimer.  
</I>&gt;<i> // 2. Redistributions in binary form must reproduce the above copyright
</I>&gt;<i> //    notice, this list of conditions and the following disclaimer in the
</I>&gt;<i> //    documentation and/or other materials provided with the distribution.  
</I>&gt;<i> // 3. Neither the name of the project nor the names of its contributors
</I>&gt;<i> //    may be used to endorse or promote products derived from this software
</I>&gt;<i> //    without specific prior written permission. 
</I>&gt;<i> // 
</I>&gt;<i> // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</I>&gt;<i> // ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
</I>&gt;<i> // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
</I>&gt;<i> // ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
</I>&gt;<i> // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</I>&gt;<i> // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</I>&gt;<i> // OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</I>&gt;<i> // HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
</I>&gt;<i> // LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
</I>&gt;<i> // OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
</I>&gt;<i> // SUCH DAMAGE.
</I>&gt;<i> // 
</I>&gt;<i>
</I>&gt;<i> //**#include &lt;os.h&gt;
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // An improved random number generation package.  In addition to the standard
</I>&gt;<i> // rand()/srand() like interface, this package also has a special state info
</I>&gt;<i> // interface.  The initstate() routine is called with a seed, an array of
</I>&gt;<i> // bytes, and a count of how many bytes are being passed in; this array is
</I>&gt;<i> // then initialized to contain information for random number generation with
</I>&gt;<i> // that much state information.  Good sizes for the amount of state
</I>&gt;<i> // information are 32, 64, 128, and 256 bytes.  The state can be switched by
</I>&gt;<i> // calling the setstate() routine with the same array as was initiallized
</I>&gt;<i> // with initstate().  By default, the package runs with 128 bytes of state
</I>&gt;<i> // information and generates far better random numbers than a linear
</I>&gt;<i> // congruential generator.  If the amount of state information is less than
</I>&gt;<i> // 32 bytes, a simple linear congruential R.N.G. is used.
</I>&gt;<i> //
</I>&gt;<i> // Internally, the state information is treated as an array of longs; the
</I>&gt;<i> // zeroeth element of the array is the type of R.N.G. being used (small
</I>&gt;<i> // integer); the remainder of the array is the state information for the
</I>&gt;<i> // R.N.G.  Thus, 32 bytes of state information will give 7 longs worth of
</I>&gt;<i> // state information, which will allow a degree seven polynomial.  (Note:
</I>&gt;<i> // the zeroeth word of state information also has some other information
</I>&gt;<i> // stored in it -- see setstate() for details).
</I>&gt;<i> //
</I>&gt;<i> // The random number generation technique is a linear feedback shift register
</I>&gt;<i> // approach, employing trinomials (since there are fewer terms to sum up that
</I>&gt;<i> // way).  In this approach, the least significant bit of all the numbers in
</I>&gt;<i> // the state table will act as a linear feedback shift register, and will
</I>&gt;<i> // have period 2^deg - 1 (where deg is the degree of the polynomial being
</I>&gt;<i> // used, assuming that the polynomial is irreducible and primitive).  The
</I>&gt;<i> // higher order bits will have longer periods, since their values are also
</I>&gt;<i> // influenced by pseudo-random carries out of the lower bits.  The total
</I>&gt;<i> // period of the generator is approximately deg*(2**deg - 1); thus doubling
</I>&gt;<i> // the amount of state information has a vast influence on the period of the
</I>&gt;<i> // generator.  Note: the deg*(2**deg - 1) is an approximation only good for
</I>&gt;<i> // large deg, when the period of the shift is the dominant factor.
</I>&gt;<i> // With deg equal to seven, the period is actually much longer than the
</I>&gt;<i> // 7*(2**7 - 1) predicted by this formula.
</I>&gt;<i> //
</I>&gt;<i> // Modified 28 December 1994 by Jacob S. Rosenberg.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // For each of the currently supported random number generators, we have a
</I>&gt;<i> // break value on the amount of state information (you need at least this
</I>&gt;<i> // many bytes of state info to support this random number generator), a degree
</I>&gt;<i> // for the polynomial (actually a trinomial) that the R.N.G. is based on, and
</I>&gt;<i> // the separation between the two lower order coefficients of the trinomial.
</I>&gt;<i>
</I>&gt;<i> void RandomGenerator::initialize() {
</I>&gt;<i>
</I>&gt;<i> #define NSHUFF 100      // To drop part of seed -&gt; 1st value correlation
</I>&gt;<i>
</I>&gt;<i> //static long degrees[MAX_TYPES] = { DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 };
</I>&gt;<i> //static long seps [MAX_TYPES] = { SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 };
</I>&gt;<i>
</I>&gt;<i>     degrees[0] = DEG_0;
</I>&gt;<i>     degrees[1] = DEG_1;
</I>&gt;<i>     degrees[2] = DEG_2;
</I>&gt;<i>     degrees[3] = DEG_3;
</I>&gt;<i>     degrees[4] = DEG_4;
</I>&gt;<i>
</I>&gt;<i>     seps [0] = SEP_0;
</I>&gt;<i>     seps [1] = SEP_1;
</I>&gt;<i>     seps [2] = SEP_2;
</I>&gt;<i>     seps [3] = SEP_3;
</I>&gt;<i>     seps [4] = SEP_4;
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // Initially, everything is set up as if from:
</I>&gt;<i> //
</I>&gt;<i> //  initstate(1, randtbl, 128);
</I>&gt;<i> //
</I>&gt;<i> // Note that this initialization takes advantage of the fact that srandom()
</I>&gt;<i> // advances the front and rear pointers 10*rand_deg times, and hence the
</I>&gt;<i> // rear pointer which starts at 0 will also end up at zero; thus the zeroeth
</I>&gt;<i> // element of the state information, which contains info about the current
</I>&gt;<i> // position of the rear pointer is just
</I>&gt;<i> //
</I>&gt;<i> //  MAX_TYPES * (rptr - state) + TYPE_3 == TYPE_3.
</I>&gt;<i>
</I>&gt;<i>     randtbl[ 0] =  TYPE_3;
</I>&gt;<i>     randtbl[ 1] =  0x991539b1;
</I>&gt;<i>     randtbl[ 2] =  0x16a5bce3;
</I>&gt;<i>     randtbl[ 3] =  0x6774a4cd;
</I>&gt;<i>     randtbl[ 4] =  0x3e01511e;
</I>&gt;<i>     randtbl[ 5] =  0x4e508aaa;
</I>&gt;<i>     randtbl[ 6] =  0x61048c05;
</I>&gt;<i>     randtbl[ 7] =  0xf5500617;
</I>&gt;<i>     randtbl[ 8] =  0x846b7115;
</I>&gt;<i>     randtbl[ 9] =  0x6a19892c;
</I>&gt;<i>     randtbl[10] =  0x896a97af;
</I>&gt;<i>     randtbl[11] =  0xdb48f936;
</I>&gt;<i>     randtbl[12] =  0x14898454;
</I>&gt;<i>     randtbl[13] =  0x37ffd106;
</I>&gt;<i>     randtbl[14] =  0xb58bff9c;
</I>&gt;<i>     randtbl[15] =  0x59e17104;
</I>&gt;<i>     randtbl[16] =  0xcf918a49;
</I>&gt;<i>     randtbl[17] =  0x09378c83;
</I>&gt;<i>     randtbl[18] =  0x52c7a471;
</I>&gt;<i>     randtbl[19] =  0x8d293ea9;
</I>&gt;<i>     randtbl[20] =  0x1f4fc301;
</I>&gt;<i>     randtbl[21] =  0xc3db71be;
</I>&gt;<i>     randtbl[22] =  0x39b44e1c;
</I>&gt;<i>     randtbl[23] =  0xf8a44ef9;
</I>&gt;<i>     randtbl[24] =  0x4c8b80b1;
</I>&gt;<i>     randtbl[25] =  0x19edc328;
</I>&gt;<i>     randtbl[26] =  0x87bf4bdd;
</I>&gt;<i>     randtbl[27] =  0xc9b240e5;
</I>&gt;<i>     randtbl[28] =  0xe9ee4b1b;
</I>&gt;<i>     randtbl[29] =  0x4382aee7;
</I>&gt;<i>     randtbl[30] =  0x535b6b41;
</I>&gt;<i>     randtbl[31] =  0xf3bec5da;
</I>&gt;<i>
</I>&gt;<i> // static long randtbl[DEG_3 + 1] = 
</I>&gt;<i> // {
</I>&gt;<i> //   TYPE_3;
</I>&gt;<i> //   0x991539b1, 0x16a5bce3, 0x6774a4cd, 0x3e01511e, 0x4e508aaa, 0x61048c05,
</I>&gt;<i> //   0xf5500617, 0x846b7115, 0x6a19892c, 0x896a97af, 0xdb48f936, 0x14898454,
</I>&gt;<i> //   0x37ffd106, 0xb58bff9c, 0x59e17104, 0xcf918a49, 0x09378c83, 0x52c7a471,
</I>&gt;<i> //   0x8d293ea9, 0x1f4fc301, 0xc3db71be, 0x39b44e1c, 0xf8a44ef9, 0x4c8b80b1,
</I>&gt;<i> //   0x19edc328, 0x87bf4bdd, 0xc9b240e5, 0xe9ee4b1b, 0x4382aee7, 0x535b6b41,
</I>&gt;<i> //   0xf3bec5da
</I>&gt;<i> // };
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // fptr and rptr are two pointers into the state info, a front and a rear
</I>&gt;<i> // pointer.  These two pointers are always rand_sep places aparts, as they
</I>&gt;<i> // cycle cyclically through the state information.  (Yes, this does mean we
</I>&gt;<i> // could get away with just one pointer, but the code for random() is more
</I>&gt;<i> // efficient this way).  The pointers are left positioned as they would be
</I>&gt;<i> // from the call
</I>&gt;<i> //
</I>&gt;<i> //  initstate(1, randtbl, 128);
</I>&gt;<i> //
</I>&gt;<i> // (The position of the rear pointer, rptr, is really 0 (as explained above
</I>&gt;<i> // in the initialization of randtbl) because the state table pointer is set
</I>&gt;<i> // to point to randtbl[1] (as explained below).
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i>     fptr = &amp;randtbl[SEP_3 + 1];
</I>&gt;<i>     rptr = &amp;randtbl[1];
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // The following things are the pointer to the state information table, the
</I>&gt;<i> // type of the current generator, the degree of the current polynomial being
</I>&gt;<i> // used, and the separation between the two pointers.  Note that for efficiency
</I>&gt;<i> // of random(), we remember the first location of the state information, not
</I>&gt;<i> // the zeroeth.  Hence it is valid to access state[-1], which is used to
</I>&gt;<i> // store the type of the R.N.G.  Also, we remember the last location, since
</I>&gt;<i> // this is more efficient than indexing every time to find the address of
</I>&gt;<i> // the last element to see if the front and rear pointers have wrapped.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i>     state = &amp;randtbl[1];
</I>&gt;<i>     rand_type = TYPE_3;
</I>&gt;<i>     rand_deg = DEG_3;
</I>&gt;<i>     rand_sep = SEP_3;
</I>&gt;<i>     end_ptr = &amp;randtbl[DEG_3 + 1];
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // Compute x = (7^5 * x) mod (2^31 - 1)
</I>&gt;<i> // wihout overflowing 31 bits:
</I>&gt;<i> //      (2^31 - 1) = 127773 * (7^5) + 2836
</I>&gt;<i> // From &quot;Random number generators: good ones are hard to find&quot;,
</I>&gt;<i> // Park and Miller, Communications of the ACM, vol. 31, no. 10,
</I>&gt;<i> // October 1988, p. 1195.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> __inline static long good_rand(long x)
</I>&gt;<i> {
</I>&gt;<i>   long hi, lo;
</I>&gt;<i>
</I>&gt;<i>   // Can't be initialized with 0, so use another value.
</I>&gt;<i>   if (x == 0) x = 123459876;
</I>&gt;<i>   hi = x / 127773;
</I>&gt;<i>   lo = x % 127773;
</I>&gt;<i>   x = 16807 * lo - 2836 * hi;
</I>&gt;<i>   if (x &lt; 0) x += 0x7fffffff;
</I>&gt;<i>   return x;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // srandom
</I>&gt;<i> //
</I>&gt;<i> // Initialize the random number generator based on the given seed.  If the
</I>&gt;<i> // type is the trivial no-state-information type, just remember the seed.
</I>&gt;<i> // Otherwise, initializes state[] based on the given &quot;seed&quot; via a linear
</I>&gt;<i> // congruential generator.  Then, the pointers are set to known locations
</I>&gt;<i> // that are exactly rand_sep places apart.  Lastly, it cycles the state
</I>&gt;<i> // information a given number of times to get rid of any initial dependencies
</I>&gt;<i> // introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
</I>&gt;<i> // for default usage relies on values produced by this routine.
</I>&gt;<i>
</I>&gt;<i> void RandomGenerator::srandom(unsigned long x)
</I>&gt;<i> {
</I>&gt;<i>   long i, lim;
</I>&gt;<i>
</I>&gt;<i>   state[0] = x;
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     lim = NSHUFF;
</I>&gt;<i>   else 
</I>&gt;<i>   {
</I>&gt;<i>     for (i = 1; i &lt; rand_deg; i++) state[i] = good_rand(state[i - 1]);
</I>&gt;<i>     fptr = &amp;state[rand_sep];
</I>&gt;<i>     rptr = &amp;state[0];
</I>&gt;<i>     lim = 10 * rand_deg;
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   initialized = 1;
</I>&gt;<i>   for (i = 0; i &lt; lim; i++) random();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> #ifdef NOT_FOR_SUPERTUX     // use in supertux doesn't require these methods,
</I>&gt;<i>                             // which are not portable to as many platforms as
</I>&gt;<i>                             // SDL.  The cost is that the variability of the
</I>&gt;<i>                             // initial seed is reduced to only 32 bits of
</I>&gt;<i>                             // randomness, seemingly enough. PAK 060420
</I>&gt;<i> //
</I>&gt;<i> // srandomdev
</I>&gt;<i> //
</I>&gt;<i> // Many programs choose the seed value in a totally predictable manner.
</I>&gt;<i> // This often causes problems.  We seed the generator using the much more
</I>&gt;<i> // secure random() interface.  Note that this particular seeding
</I>&gt;<i> // procedure can generate states which are impossible to reproduce by
</I>&gt;<i> // calling srandom() with any value, since the succeeding terms in the
</I>&gt;<i> // state buffer are no longer derived from the LC algorithm applied to
</I>&gt;<i> // a fixed seed.
</I>&gt;<i>
</I>&gt;<i> void RandomGenerator::srandomdev()
</I>&gt;<i> {
</I>&gt;<i>   int fd, done;
</I>&gt;<i>   size_t len;
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     len = sizeof state[0];
</I>&gt;<i>   else
</I>&gt;<i>     len = rand_deg * sizeof state[0];
</I>&gt;<i>
</I>&gt;<i>   done = 0;
</I>&gt;<i>   fd = open(&quot;/dev/urandom&quot;, O_RDONLY);
</I>&gt;<i>   if (fd &gt;= 0) 
</I>&gt;<i>    {
</I>&gt;<i>      if (read(fd, state, len) == len) done = 1;
</I>&gt;<i>      close(fd);
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i>   if (!done) 
</I>&gt;<i>   {
</I>&gt;<i>     struct timeval tv;
</I>&gt;<i>
</I>&gt;<i>     gettimeofday(&amp;tv, NULL);
</I>&gt;<i>     srandom(tv.tv_sec ^ tv.tv_usec);
</I>&gt;<i>     return;
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   if (rand_type != TYPE_0) 
</I>&gt;<i>   {
</I>&gt;<i>     fptr = &amp;state[rand_sep];
</I>&gt;<i>     rptr = &amp;state[0];
</I>&gt;<i>   }
</I>&gt;<i>   initialized = 1;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // initstate
</I>&gt;<i> //
</I>&gt;<i> // Initialize the state information in the given array of n bytes for future
</I>&gt;<i> // random number generation.  Based on the number of bytes we are given, and
</I>&gt;<i> // the break values for the different R.N.G.'s, we choose the best (largest)
</I>&gt;<i> // one we can and set things up for it.  srandom() is then called to
</I>&gt;<i> // initialize the state information.
</I>&gt;<i> //
</I>&gt;<i> // Note that on return from srandom(), we set state[-1] to be the type
</I>&gt;<i> // multiplexed with the current value of the rear pointer; this is so
</I>&gt;<i> // successive calls to initstate() won't lose this information and will be
</I>&gt;<i> // able to restart with setstate().
</I>&gt;<i> //
</I>&gt;<i> // Note: the first thing we do is save the current state, if any, just like
</I>&gt;<i> // setstate() so that it doesn't matter when initstate is called.
</I>&gt;<i> //
</I>&gt;<i> // Returns a pointer to the old state.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> char * RandomGenerator::initstate(unsigned long seed, char *arg_state, long n)
</I>&gt;<i> {
</I>&gt;<i>   char *ostate = (char *) (&amp;state[-1]);
</I>&gt;<i>   long *long_arg_state = (long *) arg_state;
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     state[-1] = rand_type;
</I>&gt;<i>   else
</I>&gt;<i>     state[-1] = MAX_TYPES * (rptr - state) + rand_type;
</I>&gt;<i>
</I>&gt;<i>   if (n &lt; BREAK_0) return NULL;
</I>&gt;<i>
</I>&gt;<i>   if (n &lt; BREAK_1) 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_0;
</I>&gt;<i>     rand_deg = DEG_0;
</I>&gt;<i>     rand_sep = SEP_0;
</I>&gt;<i>   } 
</I>&gt;<i>   else if (n &lt; BREAK_2) 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_1;
</I>&gt;<i>     rand_deg = DEG_1;
</I>&gt;<i>     rand_sep = SEP_1;
</I>&gt;<i>   } 
</I>&gt;<i>   else if (n &lt; BREAK_3) 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_2;
</I>&gt;<i>     rand_deg = DEG_2;
</I>&gt;<i>     rand_sep = SEP_2;
</I>&gt;<i>   } 
</I>&gt;<i>   else if (n &lt; BREAK_4) 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_3;
</I>&gt;<i>     rand_deg = DEG_3;
</I>&gt;<i>     rand_sep = SEP_3;
</I>&gt;<i>   } 
</I>&gt;<i>   else 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_4;
</I>&gt;<i>     rand_deg = DEG_4;
</I>&gt;<i>     rand_sep = SEP_4;
</I>&gt;<i>   }
</I>&gt;<i>   
</I>&gt;<i>   state = (long *) (long_arg_state + 1); // First location
</I>&gt;<i>   end_ptr = &amp;state[rand_deg]; // Must set end_ptr before srandom
</I>&gt;<i>   srandom(seed);
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     long_arg_state[0] = rand_type;
</I>&gt;<i>   else
</I>&gt;<i>     long_arg_state[0] = MAX_TYPES * (rptr - state) + rand_type;
</I>&gt;<i>
</I>&gt;<i>   initialized = 1;
</I>&gt;<i>   return ostate;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // setstate
</I>&gt;<i> //
</I>&gt;<i> // Restore the state from the given state array.
</I>&gt;<i> //
</I>&gt;<i> // Note: it is important that we also remember the locations of the pointers
</I>&gt;<i> // in the current state information, and restore the locations of the pointers
</I>&gt;<i> // from the old state information.  This is done by multiplexing the pointer
</I>&gt;<i> // location into the zeroeth word of the state information.
</I>&gt;<i> //
</I>&gt;<i> // Note that due to the order in which things are done, it is OK to call
</I>&gt;<i> // setstate() with the same state as the current state.
</I>&gt;<i> //
</I>&gt;<i> // Returns a pointer to the old state information.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> char * RandomGenerator::setstate(char *arg_state)
</I>&gt;<i> {
</I>&gt;<i>   long *new_state = (long *) arg_state;
</I>&gt;<i>   long type = new_state[0] % MAX_TYPES;
</I>&gt;<i>   long rear = new_state[0] / MAX_TYPES;
</I>&gt;<i>   char *ostate = (char *) (&amp;state[-1]);
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     state[-1] = rand_type;
</I>&gt;<i>   else
</I>&gt;<i>     state[-1] = MAX_TYPES * (rptr - state) + rand_type;
</I>&gt;<i>
</I>&gt;<i>   switch(type) 
</I>&gt;<i>   {
</I>&gt;<i>     case TYPE_0:
</I>&gt;<i>     case TYPE_1:
</I>&gt;<i>     case TYPE_2:
</I>&gt;<i>     case TYPE_3:
</I>&gt;<i>     case TYPE_4:
</I>&gt;<i>       rand_type = type;
</I>&gt;<i>       rand_deg = degrees[type];
</I>&gt;<i>       rand_sep = seps[type];
</I>&gt;<i>       break;
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   state = (long *) (new_state + 1);
</I>&gt;<i>   if (rand_type != TYPE_0) 
</I>&gt;<i>   {
</I>&gt;<i>     rptr = &amp;state[rear];
</I>&gt;<i>     fptr = &amp;state[(rear + rand_sep) % rand_deg];
</I>&gt;<i>   }
</I>&gt;<i>   end_ptr = &amp;state[rand_deg];   // Set end_ptr too
</I>&gt;<i>
</I>&gt;<i>   initialized = 1;
</I>&gt;<i>   return ostate;
</I>&gt;<i> }
</I>&gt;<i> #endif //NOT_FOR_SUPERTUX
</I>&gt;<i> //
</I>&gt;<i> // random:
</I>&gt;<i> //
</I>&gt;<i> // If we are using the trivial TYPE_0 R.N.G., just do the old linear
</I>&gt;<i> // congruential bit.  Otherwise, we do our fancy trinomial stuff, which is
</I>&gt;<i> // the same in all the other cases due to all the global variables that have
</I>&gt;<i> // been set up.  The basic operation is to add the number at the rear pointer
</I>&gt;<i> // into the one at the front pointer.  Then both pointers are advanced to
</I>&gt;<i> // the next location cyclically in the table.  The value returned is the sum
</I>&gt;<i> // generated, reduced to 31 bits by throwing away the &quot;least random&quot; low bit.
</I>&gt;<i> //
</I>&gt;<i> // Note: the code takes advantage of the fact that both the front and
</I>&gt;<i> // rear pointers can't wrap on the same call by not testing the rear
</I>&gt;<i> // pointer if the front one has wrapped.
</I>&gt;<i> //
</I>&gt;<i> // Returns a 31-bit random number.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> long RandomGenerator::random()
</I>&gt;<i> {
</I>&gt;<i>   long i;
</I>&gt;<i>   long *f, *r;
</I>&gt;<i>   if (!initialized) {
</I>&gt;<i>       throw std::runtime_error(&quot;uninitialized RandomGenerator object&quot;);
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0) 
</I>&gt;<i>   {
</I>&gt;<i>     i = state[0];
</I>&gt;<i>     state[0] = i = (good_rand(i)) &amp; 0x7fffffff;
</I>&gt;<i>   } 
</I>&gt;<i>   else 
</I>&gt;<i>   {
</I>&gt;<i>     f = fptr; r = rptr;
</I>&gt;<i>     *f += *r;
</I>&gt;<i>     i = (*f &gt;&gt; 1) &amp; 0x7fffffff; // Chucking least random bit
</I>&gt;<i>     if (++f &gt;= end_ptr) 
</I>&gt;<i>     {
</I>&gt;<i>       f = state;
</I>&gt;<i>       ++r;
</I>&gt;<i>     }
</I>&gt;<i>     else if (++r &gt;= end_ptr) 
</I>&gt;<i>       r = state;
</I>&gt;<i>
</I>&gt;<i>     fptr = f; rptr = r;
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   return i;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>   
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/supertux-devel/attachments/20060429/a9ad637e/attachment.html">https://lists.berlios.de/pipermail/supertux-devel/attachments/20060429/a9ad637e/attachment.html</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000182.html">[Supertux-devel] dev version bug
</A></li>
	<LI>Next message: <A HREF="000187.html">[Supertux-devel] dev version bug
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#183">[ date ]</a>
              <a href="thread.html#183">[ thread ]</a>
              <a href="subject.html#183">[ subject ]</a>
              <a href="author.html#183">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/supertux-devel">More information about the Supertux-devel
mailing list</a><br>
</body></html>
