<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Supertux-devel] dev version bug
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/supertux-devel/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:supertux-devel%40lists.berlios.de?Subject=Re%3A%20%5BSupertux-devel%5D%20dev%20version%20bug&In-Reply-To=%3Ce5aaa77a0604301257i340e4a8fy75a82952a827f382%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000183.html">
   <LINK REL="Next"  HREF="000173.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Supertux-devel] dev version bug</H1>
    <B>Joth Esmo</B> 
    <A HREF="mailto:supertux-devel%40lists.berlios.de?Subject=Re%3A%20%5BSupertux-devel%5D%20dev%20version%20bug&In-Reply-To=%3Ce5aaa77a0604301257i340e4a8fy75a82952a827f382%40mail.gmail.com%3E"
       TITLE="[Supertux-devel] dev version bug">jothesmo at gmail.com
       </A><BR>
    <I>Sun Apr 30 21:57:40 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000183.html">[Supertux-devel] dev version bug
</A></li>
        <LI>Next message: <A HREF="000173.html">[Supertux-devel] Snow appearance
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#187">[ date ]</a>
              <a href="thread.html#187">[ thread ]</a>
              <a href="subject.html#187">[ subject ]</a>
              <a href="author.html#187">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Greetings,

Thanks for clearing everything up. Attached is random_generator.cpp
with the stderr file. In case you can't access it, here's the
important stuff:

==== srand(1146426740) (         0) RAND_MAX=7fff =====
ERROR: x=44551574, x0=0, RAND_MAX=7fff
Assertion failed: 0, file src/random_generator.cpp, line 77

Regards,
Joth

On 4/29/06, Allen King &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/supertux-devel">allen at a-king.us</A>&gt; wrote:
&gt;<i> Joth,
</I>&gt;<i>
</I>&gt;<i>    Thanks for getting back to me so quickly, and with all the right data.
</I>&gt;<i>
</I>&gt;<i> There may have been a mis-understanding. The experiment I'm asking you to do
</I>&gt;<i> is not to fix your problem, but to produce additional output in the failing
</I>&gt;<i> mode that will help me isolate another suspected related problem.  (Below, I
</I>&gt;<i> will tell you how to get the code to work, but not here.)
</I>&gt;<i>
</I>&gt;<i> So here are some points I want to make very clear. (Sorry if this is
</I>&gt;<i> obvious, and I'm being blunt.):
</I>&gt;<i>
</I>&gt;<i> The newer version of the RandomGenerator::srand method code I sent you also
</I>&gt;<i> fail.  I want it to.  As such, that line 72 of random_generator.cpp (the
</I>&gt;<i> &quot;assert(0);&quot;) fails is not a problem for this test, it is good.
</I>&gt;<i> Line 68 should be of a form &quot;if (x &lt; RAND_MAX)&quot; to duplicate the failure.
</I>&gt;<i> In particular, it should not be modified to &quot;if (x &lt;= RAND_MAX)&quot;, or the
</I>&gt;<i> failure may change or perhaps go away.  ACTION: change line 68 from &quot;&lt;=&quot;
</I>&gt;<i> back to &quot;&lt;&quot;, so the failure will be replicated.
</I>&gt;<i> I see no line like &quot;==== srand(ddd) (ddd) RAND_MAX=xxx =====&quot; (where ddd
</I>&gt;<i> (xxx) are some decimal (hex) numbers) in your console output.  QUESTION:
</I>&gt;<i> Double and tripple check. Did you perhaps not compile the changes, or not
</I>&gt;<i> use the patched version when making the new console output?
</I>&gt;<i> If the above gets you lines like &quot;=====....&quot; above in the console output,
</I>&gt;<i> you're done, send be back the console and random_generator.cpp, and ignore
</I>&gt;<i> this.  If still no such lines appear, I'm wondering if your console log is
</I>&gt;<i> only monitoring things to standard error.  To get these printouts also on
</I>&gt;<i> standard error, try changing the string &quot;printf(&quot; to &quot;fprintf(stderr, &quot;, in
</I>&gt;<i> lines 67 and 71.  (You may or may not need to add a &quot;#include &lt;stdio.h&gt;&quot;
</I>&gt;<i> line to compile properly.) At this point, the routine in question should
</I>&gt;<i> look like the following:
</I>&gt;<i> #include &lt;stdio.h&gt;
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;<i>     int x0 = x;
</I>&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;<i>     fprintf(stderr, &quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, x0,
</I>&gt;<i> RAND_MAX);
</I>&gt;<i>
</I>&gt;<i>     if (x &lt; RAND_MAX) {
</I>&gt;<i>     }
</I>&gt;<i>     else {                                  // only allow
</I>&gt;<i> posative 31-bit seeds
</I>&gt;<i>         fprintf(stderr, &quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0,
</I>&gt;<i> RAND_MAX);
</I>&gt;<i>
</I>&gt;<i>         assert(0);
</I>&gt;<i>     }
</I>&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;<i>     return x;                               // let caller
</I>&gt;<i> know seed used
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> When you get the line with the &quot;====...&quot; in it, send me back the same stuff
</I>&gt;<i> as before, except don't bother with the config file -- it's good.
</I>&gt;<i>
</I>&gt;<i> If you can't get the &quot;====...&quot; line, try commenting out the assert(0) above,
</I>&gt;<i> and replace the following routine:
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand(int v) {
</I>&gt;<i>     assert(v != 0 &amp;&amp; v &lt;= RAND_MAX);
</I>&gt;<i>     int rv = RandomGenerator::random();
</I>&gt;<i>     printf(&quot;===x= rand(%10d) (%10d) RAND_MAX=%x =x====\n&quot;, v, rv, RAND_MAX);
</I>&gt;<i>     fprintf(stderr, &quot;==== rand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, v, rv,
</I>&gt;<i> RAND_MAX);
</I>&gt;<i>     return rv % v;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Short of that, can I have VNC  access to your machine?  Hopefully it won't
</I>&gt;<i> get to that!
</I>&gt;<i>
</I>&gt;<i>     Allen
</I>&gt;<i>
</I>&gt;<i> P.S.:  To run supertux, use the origional code (without any of the mods I've
</I>&gt;<i> been feeding to you for debug), and comment out the &quot;assert(x&lt;RAND_MAX);&quot;
</I>&gt;<i> line.
</I>&gt;<i>
</I>&gt;<i> Joth Esmo wrote:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;<i>     int x0 = x;
</I>&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;<i>     fprintf(stderr, &quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, x0,
</I>&gt;<i> RAND_MAX);
</I>&gt;<i>
</I>&gt;<i>     if (x &lt; RAND_MAX) {
</I>&gt;<i>     }
</I>&gt;<i>     else {                                  // only allow
</I>&gt;<i> posative 31-bit seeds
</I>&gt;<i>         fprintf(stderr, &quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0,
</I>&gt;<i> RAND_MAX);
</I>&gt;<i>
</I>&gt;<i>         assert(0);
</I>&gt;<i>     }
</I>&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;<i>     return x;                               // let caller
</I>&gt;<i> know seed used
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> When you get the line with the &quot;====...&quot; in it, send me back the same stuff
</I>&gt;<i> as before, except don't bother with the config file -- it's good.
</I>&gt;<i>
</I>&gt;<i> If you can't get the &quot;====...&quot; line, try commenting out the assert(0) above,
</I>&gt;<i> and replace the following routine:
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand(int v) {
</I>&gt;<i>     assert(v != 0 &amp;&amp; v &lt;= RAND_MAX);
</I>&gt;<i>     int rv = RandomGenerator::random();
</I>&gt;<i>     printf(&quot;===x= rand(%10d) (%10d) RAND_MAX=%x =x====\n&quot;, v, rv, RAND_MAX);
</I>&gt;<i>     fprintf(stderr, &quot;==== rand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, v, rv,
</I>&gt;<i> RAND_MAX);
</I>&gt;<i>     return rv % v;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Short of that, can I have VNC  access to your machine?  Hopefully it won't
</I>&gt;<i> get to that!
</I>&gt;<i>
</I>&gt;<i>     Allen
</I>&gt;<i>
</I>&gt;<i> P.S.:  To run supertux, use the origional code (without any of the mods I've
</I>&gt;<i> been feeding to you for debug), and comment out the &quot;assert(x&lt;RAND_MAX);&quot;
</I>&gt;<i> line.
</I>&gt;<i>
</I>&gt;<i> Joth Esmo wrote:
</I>&gt;<i> I replaced the text in the .cpp file as you asked and compiled. The
</I>&gt;<i> error log (stderr) is attached. Line 72 of random_generator.cpp seems
</I>&gt;<i> to be the problem (the line being: assert(0);). Also attached is my
</I>&gt;<i> ./supertux/config file. I start the application by opening MSYS,
</I>&gt;<i> navigating to my supertux directory, and issuing the command
</I>&gt;<i> 'supertux.exe -w' (as per the Building on Windows page on the wiki --
</I>&gt;<i> however the -w has been recently removed).
</I>&gt;<i>
</I>&gt;<i> In your email, you asked for the patched version of random_seed.cpp. I
</I>&gt;<i> assume you meant random_generator.cpp, which is attached.
</I>&gt;<i>
</I>&gt;<i> I'm not sure what you mean by 'capable of debug'. Should I debug it
</I>&gt;<i> and then watch the value of the config variable? I didn't quite
</I>&gt;<i> understand your meaning.
</I>&gt;<i>
</I>&gt;<i> PS&gt; I changed the text in random_generator.cpp to read : x &lt;= RAND_MAX
</I>&gt;<i> (as you requested).
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Joth
</I>&gt;<i>
</I>&gt;<i> On 4/29/06, Allen King &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/supertux-devel">allen at a-king.us</A>&gt; wrote:
</I>&gt;<i> Joth,
</I>&gt;<i>
</I>&gt;<i> A new patch to fix that problem is in the works, and should be in svn
</I>&gt;<i> shortly.  Should have been x &lt;= RAND_MAX. For the moment, that line can be
</I>&gt;<i> commented out, or the &lt; changed to &lt;= .
</I>&gt;<i>
</I>&gt;<i> But the fact that this problem happened at all is curious to me, and I
</I>&gt;<i> suspect another bug lurking nearby.  In particular, I would like to
</I>&gt;<i> understand what about your XP setup caused that assertion error.  If
</I>&gt;<i> RAND_MAX is 0x7fffffff, the largest int32, it would be improbably that
</I>&gt;<i> time(0) would generate that (unless it's not working).  Or perhaps RAND_MAX
</I>&gt;<i> is smaller.
</I>&gt;<i>
</I>&gt;<i> If you can patch to the source code, would you replace the routine in
</I>&gt;<i> random_generator.cpp with
</I>&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;<i>     int x0 = x;
</I>&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;<i>     printf(&quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, x0, RAND_MAX);
</I>&gt;<i>     if (x &lt; RAND_MAX) {
</I>&gt;<i>     }
</I>&gt;<i>     else {                                  // only allow
</I>&gt;<i> posative 31-bit
</I>&gt;<i> seeds
</I>&gt;<i>         printf(&quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0, RAND_MAX);
</I>&gt;<i>         assert(0);
</I>&gt;<i>     }
</I>&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;<i>     return x;                               // let caller
</I>&gt;<i> know seed used
</I>&gt;<i> }
</I>&gt;<i> and recreate the failure.  Send me the command line used to invoke supertux,
</I>&gt;<i> the failing printout (as you did), a copy of your ~/.supertux/config file,
</I>&gt;<i> and the patched copy of random_seed.cpp.  If you are you capable of debug,
</I>&gt;<i> the variable config-&gt;random_seed should be traced.  Is it RAND_MAX at the
</I>&gt;<i> assertion failure?  Who sets it that?
</I>&gt;<i>
</I>&gt;<i> Thanks for your help on this.
</I>&gt;<i>
</I>&gt;<i>        Allen
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Jonathan Campbell wrote:
</I>&gt;<i>
</I>&gt;<i> Greetings I just finished compiling the development version of SuperTux (the
</I>&gt;<i> newest build) and tried to launch it. However, it quits after showing a
</I>&gt;<i> transparent window. The file stderr has the following: [INFO]
</I>&gt;<i> src/main.cpp:195 [C:\Documents and
</I>&gt;<i> Settings\Administrator\.supertux] is in the search path
</I>&gt;<i> [INFO] src/main.cpp:195 [c:\msys\1.0\build\supertux\/data]
</I>&gt;<i> is in the search path [INFO] src/main.cpp:429 Component 'controller'
</I>&gt;<i> finished after 0.2 seconds [INFO] src/main.cpp:68 Couldn't load config file:
</I>&gt;<i> Couldn't open file 'config': The system cannot find the file specified. ,
</I>&gt;<i> using default settings [INFO] src/main.cpp:429 Component 'config' finished
</I>&gt;<i> after 0 seconds [INFO] src/main.cpp:429 Component 'tinygettext' finished
</I>&gt;<i> after 0.001 seconds [INFO] src/main.cpp:429 Component 'commandline' finished
</I>&gt;<i> after 0 seconds [INFO] src/main.cpp:429 Component 'audio' finished after
</I>&gt;<i> 0.202 seconds [INFO] src/main.cpp:429 Component 'video' finished after 0.278
</I>&gt;<i> seconds [INFO] src/main.cpp:429 Component 'scripting' finished after 0.005
</I>&gt;<i> seconds [DEBUG] src/tile_manager.cpp:47 Tiles loaded in 0.059 seconds [INFO]
</I>&gt;<i> src/main.cpp:429 Component 'resources' finished after 0.236 seconds
</I>&gt;<i> Assertion failed: x &lt; RAND_MAX, file src/random_generator.cpp, line 57 I'm
</I>&gt;<i> running Windows XP with all updates installed. To compile it, I followed the
</I>&gt;<i> instructions on this page on the wiki:
</I>&gt;<i> <A HREF="http://supertux.berlios.de/wiki/index.php/Building_on_Windows">http://supertux.berlios.de/wiki/index.php/Building_on_Windows</A>
</I>&gt;<i> Any help would be appreciated. I'd really like to see this new version of
</I>&gt;<i> SuperTux. Regards, Joth Esmo
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Supertux-devel mailing list <A HREF="https://lists.berlios.de/mailman/listinfo/supertux-devel">Supertux-devel at lists.berlios.de</A>
</I>&gt;<i> <A HREF="http://lists.berlios.de/mailman/listinfo/supertux-devel">http://lists.berlios.de/mailman/listinfo/supertux-devel</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> Flarbland: Your one and only stop for cheats, articles, comedy and
</I>&gt;<i> much, much more!
</I>&gt;<i> <A HREF="http://flarbland.bravehost.com">http://flarbland.bravehost.com</A>
</I>&gt;<i> ________________________________
</I>&gt;<i>
</I>[INFO] src/main.cpp:195 [C:\Documents and
&gt;<i> Settings\HP_Administrator\.supertux] is in the search
</I>&gt;<i> path
</I>[INFO] src/main.cpp:195
&gt;<i> [c:\msys\1.0\build\supertux2\/data] is in the search
</I>&gt;<i> path
</I>[INFO] src/main.cpp:429 Component 'controller' finished after 0.2
&gt;<i> seconds
</I>[WARNING]
&gt;<i> src/control/joystickkeyboardcontroller.cpp:192 Invalid
</I>&gt;<i> button '0' in buttonmap
</I>[WARNING]
&gt;<i> src/control/joystickkeyboardcontroller.cpp:192 Invalid
</I>&gt;<i> button '1' in buttonmap
</I>[INFO] src/main.cpp:429 Component 'config' finished
&gt;<i> after 0.021 seconds
</I>[INFO] src/main.cpp:429 Component 'tinygettext' finished
&gt;<i> after 0 seconds
</I>[INFO] src/main.cpp:429 Component 'commandline' finished
&gt;<i> after 0 seconds
</I>[INFO] src/main.cpp:429 Component 'audio' finished after
&gt;<i> 0.302 seconds
</I>[INFO] src/main.cpp:429 Component 'video' finished after 0.432
&gt;<i> seconds
</I>[INFO] src/main.cpp:429 Component 'scripting' finished after 0.034
&gt;<i> seconds
</I>[DEBUG] src/tile_manager.cpp:47 Tiles loaded in 0.057 seconds
[INFO]
&gt;<i> src/main.cpp:429 Component 'resources' finished after 0.217
</I>&gt;<i> seconds
</I>Assertion failed: 0, file src/random_generator.cpp, line 72

This
&gt;<i> application has requested the Runtime to terminate it in an unusual
</I>&gt;<i> way.
</I>Please contact the application's support team for more
&gt;<i> information.
</I>





&gt;<i> ________________________________
</I>&gt;<i>
</I>(supertux-config
 (show_fps #f)
 (cheats #f)
 (video
 (fullscreen #t)
&gt;<i> (width 800)
</I> (height 600)
 )
 (audio
 (sound_enabled #t)
 (music_enabled
&gt;<i> #t)
</I> )
 (control
 (keymap
 (map
 (key 13)
 (control &quot;menu-select&quot;)
 )
 (map
&gt;<i> (key 19)
</I> (control &quot;pause-menu&quot;)
 )
 (map
 (key 27)
 (control &quot;pause-menu&quot;)
&gt;<i> )
</I> (map
 (key 94)
 (control &quot;console&quot;)
 )
 (map
 (key 112)
 (control
&gt;<i> &quot;pause-menu&quot;)
</I> )
 (map
 (key 271)
 (control &quot;menu-select&quot;)
 )
 (map
 (key
&gt;<i> 273)
</I> (control &quot;jump&quot;)
 )
 (map
 (key 274)
 (control &quot;down&quot;)
 )
 (map
 (key
&gt;<i> 275)
</I> (control &quot;right&quot;)
 )
 (map
 (key 276)
 (control &quot;left&quot;)
 )
 (map
 (key
&gt;<i> 303)
</I> (control &quot;up&quot;)
 )
 (map
 (key 304)
 (control &quot;action&quot;)
 )
 )
&gt;<i> (joystick
</I> (use_hat #t)
 (axis_x 0)
 (axis_y 1)
 (dead_zone_x 1000)
&gt;<i> (dead_zone_y 1000)
</I> (map
 (button 0)
 (control &quot;jump&quot;)
 )
 (map
 (button 1)
&gt;<i> (control &quot;action&quot;)
</I> )
 )
 )
)





&gt;<i> ________________________________
</I>&gt;<i>
</I>// $Id: random_generator.cpp 3435 2006-04-26 02:13:42Z sik0fewl $
//
// A
&gt;<i> strong random number generator
</I>//
// Copyright (C) 2006 Allen King
//
&gt;<i> Copyright (C) 2002 Michael Ringgaard. All rights reserved.
</I>// Copyright (C)
&gt;<i> 1983, 1993 The Regents of the University of California.
</I>//
// Redistribution
&gt;<i> and use in source and binary forms, with or without
</I>// modification, are
&gt;<i> permitted provided that the following conditions
</I>// are met:
//
// 1.
&gt;<i> Redistributions of source code must retain the above copyright
</I>// notice,
&gt;<i> this list of conditions and the following disclaimer.
</I>// 2. Redistributions
&gt;<i> in binary form must reproduce the above copyright
</I>// notice, this list of
&gt;<i> conditions and the following disclaimer in the
</I>// documentation and/or other
&gt;<i> materials provided with the distribution.
</I>// 3. Neither the name of the
&gt;<i> project nor the names of its contributors
</I>// may be used to endorse or
&gt;<i> promote products derived from this software
</I>// without specific prior
&gt;<i> written permission.
</I>//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
&gt;<i> HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</I>// ANY EXPRESS OR IMPLIED WARRANTIES,
&gt;<i> INCLUDING, BUT NOT LIMITED TO, THE
</I>// IMPLIED WARRANTIES OF MERCHANTABILITY
&gt;<i> AND FITNESS FOR A PARTICULAR PURPOSE
</I>// ARE DISCLAIMED. IN NO EVENT SHALL
&gt;<i> THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
</I>// FOR ANY DIRECT, INDIRECT,
&gt;<i> INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</I>// DAMAGES (INCLUDING, BUT
&gt;<i> NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</I>// OR SERVICES; LOSS OF USE,
&gt;<i> DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</I>// HOWEVER CAUSED AND ON ANY
&gt;<i> THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
</I>// LIABILITY, OR TORT
&gt;<i> (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
</I>// OUT OF THE USE OF
&gt;<i> THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
</I>// SUCH DAMAGE.

//
&gt;<i> Transliterated into C++ Allen King 060417, from sources on
</I>//
&gt;<i> <A HREF="http://www.jbox.dk/sanos/source/lib/random.c.html">http://www.jbox.dk/sanos/source/lib/random.c.html</A>
</I>


#include
&gt;<i> &lt;stdexcept&gt;
</I>#include &quot;random_generator.hpp&quot;
#include
&gt;<i> &quot;scripting/squirrel_util.hpp&quot;
</I>
RandomGenerator systemRandom; // global
&gt;<i> random number generator
</I>
RandomGenerator::RandomGenerator()
&gt;<i> {
</I> assert(sizeof(int) &gt;= 4);
 initialized = 0;
&gt;<i> initialize();
</I>}

RandomGenerator::~RandomGenerator()
&gt;<i> {
</I>}

/*int RandomGenerator::srand(int x) {
 while (x == 0) // random seed of
&gt;<i> zero means
</I> x = time(0); // randomize with time
 assert(x &lt; RAND_MAX); //
&gt;<i> only allow posative 31-bit seeds
</I> assert(sizeof(int) &gt;= 4);
 srandom(x);
&gt;<i> return x; // let caller know seed used
</I>}*/

int RandomGenerator::srand(int
&gt;<i> x) {
</I> int x0 = x;
 while (x == 0) // random seed of zero means
 x = time(0);
&gt;<i> // randomize with time
</I> printf(&quot;==== srand(%10d) (%10d) RAND_MAX=%x
&gt;<i> =====\n&quot;, x, x0, RAND_MAX);
</I> if (x &lt;= RAND_MAX) {
 }
 else { // only allow
&gt;<i> posative 31-bit seeds
</I> printf(&quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0,
&gt;<i> RAND_MAX);
</I> assert(0);
 }
 RandomGenerator::srandom(x);
 return x; // let
&gt;<i> caller know seed used
</I>}

int RandomGenerator::rand() { return random();
&gt;<i> }
</I>
int RandomGenerator::rand(int v) {
 assert(v != 0 &amp;&amp; v &lt;= RAND_MAX); //
&gt;<i> illegal arg: 0 or too big
</I> return RandomGenerator::random() % v;
}

int
&gt;<i> RandomGenerator::rand(int u, int v) {
</I> assert(v &gt; u);
 return u +
&gt;<i> RandomGenerator::rand(v-u);
</I>}

double RandomGenerator::randf(double v) {
&gt;<i> float rv;
</I> while ((rv = (double)RandomGenerator::random() /
&gt;<i> RAND_MAX * v) &gt;= v)
</I> ; // never return v!
 return rv;
}

double
&gt;<i> RandomGenerator::randf(double u, double v) {
</I> return u +
&gt;<i> RandomGenerator::randf(v-u);
</I>}

//-----------------------------------------------------------------------
//
&gt;<i>
</I>// Copyright (C) 2002 Michael Ringgaard. All rights reserved.
// Copyright
&gt;<i> (C) 1983, 1993 The Regents of the University of California.
</I>//
//
&gt;<i> Redistribution and use in source and binary forms, with or without
</I>//
&gt;<i> modification, are permitted provided that the following conditions
</I>// are
&gt;<i> met:
</I>//
// 1. Redistributions of source code must retain the above
&gt;<i> copyright
</I>// notice, this list of conditions and the following disclaimer.
&gt;<i>
</I>// 2. Redistributions in binary form must reproduce the above copyright
//
&gt;<i> notice, this list of conditions and the following disclaimer in the
</I>//
&gt;<i> documentation and/or other materials provided with the distribution.
</I>// 3.
&gt;<i> Neither the name of the project nor the names of its contributors
</I>// may be
&gt;<i> used to endorse or promote products derived from this software
</I>// without
&gt;<i> specific prior written permission.
</I>//
// THIS SOFTWARE IS PROVIDED BY THE
&gt;<i> COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</I>// ANY EXPRESS OR IMPLIED
&gt;<i> WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
</I>// IMPLIED WARRANTIES OF
&gt;<i> MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
</I>// ARE DISCLAIMED. IN
&gt;<i> NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
</I>// FOR ANY
&gt;<i> DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</I>//
&gt;<i> DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</I>//
&gt;<i> OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</I>//
&gt;<i> HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
</I>&gt;<i> STRICT
</I>// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
&gt;<i> ANY WAY
</I>// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
&gt;<i> POSSIBILITY OF
</I>// SUCH DAMAGE.
//

//**#include &lt;os.h&gt;

//
// An improved
&gt;<i> random number generation package. In addition to the standard
</I>//
&gt;<i> rand()/srand() like interface, this package also has a special state info
</I>//
&gt;<i> interface. The initstate() routine is called with a seed, an array of
</I>//
&gt;<i> bytes, and a count of how many bytes are being passed in; this array is
</I>//
&gt;<i> then initialized to contain information for random number generation with
</I>//
&gt;<i> that much state information. Good sizes for the amount of state
</I>//
&gt;<i> information are 32, 64, 128, and 256 bytes. The state can be switched by
</I>//
&gt;<i> calling the setstate() routine with the same array as was initiallized
</I>//
&gt;<i> with initstate(). By default, the package runs with 128 bytes of state
</I>//
&gt;<i> information and generates far better random numbers than a linear
</I>//
&gt;<i> congruential generator. If the amount of state information is less than
</I>//
&gt;<i> 32 bytes, a simple linear congruential R.N.G. is used.
</I>//
// Internally, the
&gt;<i> state information is treated as an array of longs; the
</I>// zeroeth element of
&gt;<i> the array is the type of R.N.G. being used (small
</I>// integer); the remainder
&gt;<i> of the array is the state information for the
</I>// R.N.G. Thus, 32 bytes of
&gt;<i> state information will give 7 longs worth of
</I>// state information, which
&gt;<i> will allow a degree seven polynomial. (Note:
</I>// the zeroeth word of state
&gt;<i> information also has some other information
</I>// stored in it -- see
&gt;<i> setstate() for details).
</I>//
// The random number generation technique is a
&gt;<i> linear feedback shift register
</I>// approach, employing trinomials (since
&gt;<i> there are fewer terms to sum up that
</I>// way). In this approach, the least
&gt;<i> significant bit of all the numbers in
</I>// the state table will act as a
&gt;<i> linear feedback shift register, and will
</I>// have period 2^deg - 1 (where deg
&gt;<i> is the degree of the polynomial being
</I>// used, assuming that the polynomial
&gt;<i> is irreducible and primitive). The
</I>// higher order bits will have longer
&gt;<i> periods, since their values are also
</I>// influenced by pseudo-random carries
&gt;<i> out of the lower bits. The total
</I>// period of the generator is approximately
&gt;<i> deg*(2**deg - 1); thus doubling
</I>// the amount of state information has a
&gt;<i> vast influence on the period of the
</I>// generator. Note: the deg*(2**deg - 1)
&gt;<i> is an approximation only good for
</I>// large deg, when the period of the shift
&gt;<i> is the dominant factor.
</I>// With deg equal to seven, the period is actually
&gt;<i> much longer than the
</I>// 7*(2**7 - 1) predicted by this formula.
//
//
&gt;<i> Modified 28 December 1994 by Jacob S. Rosenberg.
</I>//

//
// For each of the
&gt;<i> currently supported random number generators, we have a
</I>// break value on
&gt;<i> the amount of state information (you need at least this
</I>// many bytes of
&gt;<i> state info to support this random number generator), a degree
</I>// for the
&gt;<i> polynomial (actually a trinomial) that the R.N.G. is based on, and
</I>// the
&gt;<i> separation between the two lower order coefficients of the trinomial.
</I>
void
&gt;<i> RandomGenerator::initialize() {
</I>
#define NSHUFF 100 // To drop part of seed
&gt;<i> -&gt; 1st value correlation
</I>
//static long degrees[MAX_TYPES] = { DEG_0, DEG_1,
&gt;<i> DEG_2, DEG_3, DEG_4 };
</I>//static long seps [MAX_TYPES] = { SEP_0, SEP_1,
&gt;<i> SEP_2, SEP_3, SEP_4 };
</I>
 degrees[0] = DEG_0;
 degrees[1] = DEG_1;
&gt;<i> degrees[2] = DEG_2;
</I> degrees[3] = DEG_3;
 degrees[4] = DEG_4;

 seps [0] =
&gt;<i> SEP_0;
</I> seps [1] = SEP_1;
 seps [2] = SEP_2;
 seps [3] = SEP_3;
 seps [4] =
&gt;<i> SEP_4;
</I>
//
// Initially, everything is set up as if from:
//
// initstate(1,
&gt;<i> randtbl, 128);
</I>//
// Note that this initialization takes advantage of the
&gt;<i> fact that srandom()
</I>// advances the front and rear pointers 10*rand_deg
&gt;<i> times, and hence the
</I>// rear pointer which starts at 0 will also end up at
&gt;<i> zero; thus the zeroeth
</I>// element of the state information, which contains
&gt;<i> info about the current
</I>// position of the rear pointer is just
//
//
&gt;<i> MAX_TYPES * (rptr - state) + TYPE_3 == TYPE_3.
</I>
 randtbl[ 0] = TYPE_3;
&gt;<i> randtbl[ 1] = 0x991539b1;
</I> randtbl[ 2] = 0x16a5bce3;
 randtbl[ 3] =
&gt;<i> 0x6774a4cd;
</I> randtbl[ 4] = 0x3e01511e;
 randtbl[ 5] = 0x4e508aaa;
 randtbl[
&gt;<i> 6] = 0x61048c05;
</I> randtbl[ 7] = 0xf5500617;
 randtbl[ 8] = 0x846b7115;
&gt;<i> randtbl[ 9] = 0x6a19892c;
</I> randtbl[10] = 0x896a97af;
 randtbl[11] =
&gt;<i> 0xdb48f936;
</I> randtbl[12] = 0x14898454;
 randtbl[13] = 0x37ffd106;
&gt;<i> randtbl[14] = 0xb58bff9c;
</I> randtbl[15] = 0x59e17104;
 randtbl[16] =
&gt;<i> 0xcf918a49;
</I> randtbl[17] = 0x09378c83;
 randtbl[18] = 0x52c7a471;
&gt;<i> randtbl[19] = 0x8d293ea9;
</I> randtbl[20] = 0x1f4fc301;
 randtbl[21] =
&gt;<i> 0xc3db71be;
</I> randtbl[22] = 0x39b44e1c;
 randtbl[23] = 0xf8a44ef9;
&gt;<i> randtbl[24] = 0x4c8b80b1;
</I> randtbl[25] = 0x19edc328;
 randtbl[26] =
&gt;<i> 0x87bf4bdd;
</I> randtbl[27] = 0xc9b240e5;
 randtbl[28] = 0xe9ee4b1b;
&gt;<i> randtbl[29] = 0x4382aee7;
</I> randtbl[30] = 0x535b6b41;
 randtbl[31] =
&gt;<i> 0xf3bec5da;
</I>
// static long randtbl[DEG_3 + 1] =
// {
// TYPE_3;
//
&gt;<i> 0x991539b1, 0x16a5bce3, 0x6774a4cd, 0x3e01511e, 0x4e508aaa, 0x61048c05,
</I>//
&gt;<i> 0xf5500617, 0x846b7115, 0x6a19892c, 0x896a97af, 0xdb48f936, 0x14898454,
</I>//
&gt;<i> 0x37ffd106, 0xb58bff9c, 0x59e17104, 0xcf918a49, 0x09378c83, 0x52c7a471,
</I>//
&gt;<i> 0x8d293ea9, 0x1f4fc301, 0xc3db71be, 0x39b44e1c, 0xf8a44ef9, 0x4c8b80b1,
</I>//
&gt;<i> 0x19edc328, 0x87bf4bdd, 0xc9b240e5, 0xe9ee4b1b, 0x4382aee7, 0x535b6b41,
</I>//
&gt;<i> 0xf3bec5da
</I>// };


//
// fptr and rptr are two pointers into the state info,
&gt;<i> a front and a rear
</I>// pointer. These two pointers are always rand_sep places
&gt;<i> aparts, as they
</I>// cycle cyclically through the state information. (Yes,
&gt;<i> this does mean we
</I>// could get away with just one pointer, but the code for
&gt;<i> random() is more
</I>// efficient this way). The pointers are left positioned as
&gt;<i> they would be
</I>// from the call
//
// initstate(1, randtbl, 128);
//
// (The
&gt;<i> position of the rear pointer, rptr, is really 0 (as explained above
</I>// in
&gt;<i> the initialization of randtbl) because the state table pointer is set
</I>// to
&gt;<i> point to randtbl[1] (as explained below).
</I>//

 fptr = &amp;randtbl[SEP_3 + 1];
&gt;<i> rptr = &amp;randtbl[1];
</I>
//
// The following things are the pointer to the state
&gt;<i> information table, the
</I>// type of the current generator, the degree of the
&gt;<i> current polynomial being
</I>// used, and the separation between the two
&gt;<i> pointers. Note that for efficiency
</I>// of random(), we remember the first
&gt;<i> location of the state information, not
</I>// the zeroeth. Hence it is valid to
&gt;<i> access state[-1], which is used to
</I>// store the type of the R.N.G. Also, we
&gt;<i> remember the last location, since
</I>// this is more efficient than indexing
&gt;<i> every time to find the address of
</I>// the last element to see if the front
&gt;<i> and rear pointers have wrapped.
</I>//

 state = &amp;randtbl[1];
 rand_type =
&gt;<i> TYPE_3;
</I> rand_deg = DEG_3;
 rand_sep = SEP_3;
 end_ptr = &amp;randtbl[DEG_3 +
&gt;<i> 1];
</I>
}

//
// Compute x = (7^5 * x) mod (2^31 - 1)
// wihout overflowing 31
&gt;<i> bits:
</I>// (2^31 - 1) = 127773 * (7^5) + 2836
// From &quot;Random number
&gt;<i> generators: good ones are hard to find&quot;,
</I>// Park and Miller, Communications
&gt;<i> of the ACM, vol. 31, no. 10,
</I>// October 1988, p. 1195.
//

__inline static
&gt;<i> long good_rand(long x)
</I>{
 long hi, lo;

 // Can't be initialized with 0, so
&gt;<i> use another value.
</I> if (x == 0) x = 123459876;
 hi = x / 127773;
 lo = x %
&gt;<i> 127773;
</I> x = 16807 * lo - 2836 * hi;
 if (x &lt; 0) x += 0x7fffffff;
 return
&gt;<i> x;
</I>}

//
// srandom
//
// Initialize the random number generator based on
&gt;<i> the given seed. If the
</I>// type is the trivial no-state-information type,
&gt;<i> just remember the seed.
</I>// Otherwise, initializes state[] based on the given
&gt;<i> &quot;seed&quot; via a linear
</I>// congruential generator. Then, the pointers are set to
&gt;<i> known locations
</I>// that are exactly rand_sep places apart. Lastly, it cycles
&gt;<i> the state
</I>// information a given number of times to get rid of any initial
&gt;<i> dependencies
</I>// introduced by the L.C.R.N.G. Note that the initialization of
&gt;<i> randtbl[]
</I>// for default usage relies on values produced by this
&gt;<i> routine.
</I>
void RandomGenerator::srandom(unsigned long x)
{
&gt;<i> long i, lim;
</I>
 state[0] = x;
 if (rand_type == TYPE_0)
 lim = NSHUFF;
 else
&gt;<i>
</I> {
 for (i = 1; i &lt; rand_deg; i++) state[i] = good_rand(state[i - 1]);
&gt;<i> fptr = &amp;state[rand_sep];
</I> rptr = &amp;state[0];
 lim = 10 * rand_deg;
 }

&gt;<i> initialized = 1;
</I> for (i = 0; i &lt; lim; i++) random();
}

#ifdef
&gt;<i> NOT_FOR_SUPERTUX // use in supertux doesn't require these methods,
</I> // which
&gt;<i> are not portable to as many platforms as
</I> // SDL. The cost is that the
&gt;<i> variability of the
</I> // initial seed is reduced to only 32 bits of
 //
&gt;<i> randomness, seemingly enough. PAK 060420
</I>//
// srandomdev
//
// Many
&gt;<i> programs choose the seed value in a totally predictable manner.
</I>// This
&gt;<i> often causes problems. We seed the generator using the much more
</I>// secure
&gt;<i> random() interface. Note that this particular seeding
</I>// procedure can
&gt;<i> generate states which are impossible to reproduce by
</I>// calling srandom()
&gt;<i> with any value, since the succeeding terms in the
</I>// state buffer are no
&gt;<i> longer derived from the LC algorithm applied to
</I>// a fixed seed.

void
&gt;<i> RandomGenerator::srandomdev()
</I>{
 int fd, done;
 size_t len;

 if (rand_type
&gt;<i> == TYPE_0)
</I> len = sizeof state[0];
 else
 len = rand_deg * sizeof
&gt;<i> state[0];
</I>
 done = 0;
 fd = open(&quot;/dev/urandom&quot;, O_RDONLY);
 if (fd &gt;= 0)
&gt;<i> {
</I> if (read(fd, state, len) == len) done = 1;
 close(fd);
 }

 if (!done)
&gt;<i> {
</I> struct timeval tv;

 gettimeofday(&amp;tv, NULL);
 srandom(tv.tv_sec ^
&gt;<i> tv.tv_usec);
</I> return;
 }

 if (rand_type != TYPE_0)
 {
 fptr =
&gt;<i> &amp;state[rand_sep];
</I> rptr = &amp;state[0];
 }
 initialized = 1;
}

//
//
&gt;<i> initstate
</I>//
// Initialize the state information in the given array of n
&gt;<i> bytes for future
</I>// random number generation. Based on the number of bytes
&gt;<i> we are given, and
</I>// the break values for the different R.N.G.'s, we choose
&gt;<i> the best (largest)
</I>// one we can and set things up for it. srandom() is then
&gt;<i> called to
</I>// initialize the state information.
//
// Note that on return
&gt;<i> from srandom(), we set state[-1] to be the type
</I>// multiplexed with the
&gt;<i> current value of the rear pointer; this is so
</I>// successive calls to
&gt;<i> initstate() won't lose this information and will be
</I>// able to restart with
&gt;<i> setstate().
</I>//
// Note: the first thing we do is save the current state, if
&gt;<i> any, just like
</I>// setstate() so that it doesn't matter when initstate is
&gt;<i> called.
</I>//
// Returns a pointer to the old state.
//

char *
&gt;<i> RandomGenerator::initstate(unsigned long seed, char
</I>&gt;<i> *arg_state, long n)
</I>{
 char *ostate = (char *) (&amp;state[-1]);
 long
&gt;<i> *long_arg_state = (long *) arg_state;
</I>
 if (rand_type == TYPE_0)
 state[-1]
&gt;<i> = rand_type;
</I> else
 state[-1] = MAX_TYPES * (rptr - state) + rand_type;

 if
&gt;<i> (n &lt; BREAK_0) return NULL;
</I>
 if (n &lt; BREAK_1)
 {
 rand_type = TYPE_0;
&gt;<i> rand_deg = DEG_0;
</I> rand_sep = SEP_0;
 }
 else if (n &lt; BREAK_2)
 {
&gt;<i> rand_type = TYPE_1;
</I> rand_deg = DEG_1;
 rand_sep = SEP_1;
 }
 else if (n &lt;
&gt;<i> BREAK_3)
</I> {
 rand_type = TYPE_2;
 rand_deg = DEG_2;
 rand_sep = SEP_2;
 }
&gt;<i> else if (n &lt; BREAK_4)
</I> {
 rand_type = TYPE_3;
 rand_deg = DEG_3;
 rand_sep
&gt;<i> = SEP_3;
</I> }
 else
 {
 rand_type = TYPE_4;
 rand_deg = DEG_4;
 rand_sep =
&gt;<i> SEP_4;
</I> }

 state = (long *) (long_arg_state + 1); // First location
&gt;<i> end_ptr = &amp;state[rand_deg]; // Must set end_ptr before srandom
</I>&gt;<i> srandom(seed);
</I>
 if (rand_type == TYPE_0)
 long_arg_state[0] = rand_type;
&gt;<i> else
</I> long_arg_state[0] = MAX_TYPES * (rptr - state) + rand_type;

&gt;<i> initialized = 1;
</I> return ostate;
}

//
// setstate
//
// Restore the state
&gt;<i> from the given state array.
</I>//
// Note: it is important that we also
&gt;<i> remember the locations of the pointers
</I>// in the current state information,
&gt;<i> and restore the locations of the pointers
</I>// from the old state information.
&gt;<i> This is done by multiplexing the pointer
</I>// location into the zeroeth word
&gt;<i> of the state information.
</I>//
// Note that due to the order in which things
&gt;<i> are done, it is OK to call
</I>// setstate() with the same state as the current
&gt;<i> state.
</I>//
// Returns a pointer to the old state information.
//

char *
&gt;<i> RandomGenerator::setstate(char *arg_state)
</I>{
 long *new_state = (long *)
&gt;<i> arg_state;
</I> long type = new_state[0] % MAX_TYPES;
 long rear = new_state[0]
&gt;<i> / MAX_TYPES;
</I> char *ostate = (char *) (&amp;state[-1]);

 if (rand_type ==
&gt;<i> TYPE_0)
</I> state[-1] = rand_type;
 else
 state[-1] = MAX_TYPES * (rptr -
&gt;<i> state) + rand_type;
</I>
 switch(type)
 {
 case TYPE_0:
 case TYPE_1:
 case
&gt;<i> TYPE_2:
</I> case TYPE_3:
 case TYPE_4:
 rand_type = type;
 rand_deg =
&gt;<i> degrees[type];
</I> rand_sep = seps[type];
 break;
 }

 state = (long *)
&gt;<i> (new_state + 1);
</I> if (rand_type != TYPE_0)
 {
 rptr = &amp;state[rear];
 fptr =
&gt;<i> &amp;state[(rear + rand_sep) % rand_deg];
</I> }
 end_ptr = &amp;state[rand_deg]; // Set
&gt;<i> end_ptr too
</I>
 initialized = 1;
 return ostate;
}
#endif
&gt;<i> //NOT_FOR_SUPERTUX
</I>//
// random:
//
// If we are using the trivial TYPE_0
&gt;<i> R.N.G., just do the old linear
</I>// congruential bit. Otherwise, we do our
&gt;<i> fancy trinomial stuff, which is
</I>// the same in all the other cases due to
&gt;<i> all the global variables that have
</I>// been set up. The basic operation is to
&gt;<i> add the number at the rear pointer
</I>// into the one at the front pointer.
&gt;<i> Then both pointers are advanced to
</I>// the next location cyclically in the
&gt;<i> table. The value returned is the sum
</I>// generated, reduced to 31 bits by
&gt;<i> throwing away the &quot;least random&quot; low bit.
</I>//
// Note: the code takes
&gt;<i> advantage of the fact that both the front and
</I>// rear pointers can't wrap on
&gt;<i> the same call by not testing the rear
</I>// pointer if the front one has
&gt;<i> wrapped.
</I>//
// Returns a 31-bit random number.
//

long
&gt;<i> RandomGenerator::random()
</I>{
 long i;
 long *f, *r;
 if (!initialized) {
&gt;<i> throw std::runtime_error(&quot;uninitialized RandomGenerator
</I>&gt;<i> object&quot;);
</I> }

 if (rand_type == TYPE_0)
 {
 i = state[0];
 state[0] = i =
&gt;<i> (good_rand(i)) &amp; 0x7fffffff;
</I> }
 else
 {
 f = fptr; r = rptr;
 *f += *r;
&gt;<i> i = (*f &gt;&gt; 1) &amp; 0x7fffffff; // Chucking least random bit
</I> if (++f &gt;=
&gt;<i> end_ptr)
</I> {
 f = state;
 ++r;
 }
 else if (++r &gt;= end_ptr)
 r = state;

&gt;<i> fptr = f; rptr = r;
</I> }

 return i;
}


&gt;<i>
</I>

--
Flarbland: Your one and only stop for cheats, articles, comedy and
much, much more!
<A HREF="http://flarbland.bravehost.com">http://flarbland.bravehost.com</A>
-------------- next part --------------
[INFO] src/main.cpp:195 [C:\Documents and Settings\HP_Administrator\.supertux] is in the search path
[INFO] src/main.cpp:195 [c:\msys\1.0\build\supertux2\/data] is in the search path
[INFO] src/main.cpp:429 Component 'controller' finished after 0.2 seconds
[WARNING] src/control/joystickkeyboardcontroller.cpp:192 Invalid button '0' in buttonmap
[WARNING] src/control/joystickkeyboardcontroller.cpp:192 Invalid button '1' in buttonmap
[INFO] src/main.cpp:429 Component 'config' finished after 0.003 seconds
[INFO] src/main.cpp:429 Component 'tinygettext' finished after 0.001 seconds
[INFO] src/main.cpp:429 Component 'commandline' finished after 0 seconds
[INFO] src/main.cpp:429 Component 'audio' finished after 0.335 seconds
[INFO] src/main.cpp:429 Component 'video' finished after 5.476 seconds
[INFO] src/main.cpp:429 Component 'scripting' finished after 0.236 seconds
[DEBUG] src/tile_manager.cpp:47 Tiles loaded in 0.463 seconds
[INFO] src/main.cpp:429 Component 'resources' finished after 3.552 seconds
==== srand(1146426740) (         0) RAND_MAX=7fff =====
ERROR: x=44551574, x0=0, RAND_MAX=7fff
Assertion failed: 0, file src/random_generator.cpp, line 77

This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
-------------- next part --------------
// $Id: random_generator.cpp 3435 2006-04-26 02:13:42Z sik0fewl $
// 
// A strong random number generator
//
// Copyright (C) 2006 Allen King
// Copyright (C) 2002 Michael Ringgaard. All rights reserved.
// Copyright (C) 1983, 1993 The Regents of the University of California.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright 
//    notice, this list of conditions and the following disclaimer.  
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.  
// 3. Neither the name of the project nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission. 
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
// SUCH DAMAGE.

// Transliterated into C++ Allen King 060417, from sources on
//          <A HREF="http://www.jbox.dk/sanos/source/lib/random.c.html">http://www.jbox.dk/sanos/source/lib/random.c.html</A>



#include &lt;stdexcept&gt;
#include &lt;stdio.h&gt;
#include &quot;random_generator.hpp&quot;
#include &quot;scripting/squirrel_util.hpp&quot;

RandomGenerator systemRandom;               // global random number generator

RandomGenerator::RandomGenerator() {
    assert(sizeof(int) &gt;= 4);
    initialized = 0;
    initialize();
}

RandomGenerator::~RandomGenerator() {
}

/*int RandomGenerator::srand(int x)    {
    while (x == 0)                          // random seed of zero means
        x = time(0);                        // randomize with time
    assert(x &lt; RAND_MAX);                   // only allow posative 31-bit seeds
    assert(sizeof(int) &gt;= 4);
    srandom(x);
    return x;                               // let caller know seed used
}*/

int RandomGenerator::srand(int x)    {
    int x0 = x;
    while (x == 0)                          // random seed of zero means
        x = time(0);                        // randomize with time

    fprintf(stderr, &quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, x0, RAND_MAX);

    if (x &lt; RAND_MAX) {
    }
    else {                                  // only allow positive 31-bit seeds

        fprintf(stderr, &quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0, RAND_MAX);

        assert(0);
    }
    RandomGenerator::srandom(x);
    return x;                               // let caller know seed used
}

int RandomGenerator::rand()                 {        return random();    }

int RandomGenerator::rand(int v) {
    assert(v != 0 &amp;&amp; v &lt;= RAND_MAX);        // illegal arg: 0 or too big
    return RandomGenerator::random() % v;
}

int RandomGenerator::rand(int u, int v) {
    assert(v &gt; u);    
    return u + RandomGenerator::rand(v-u);
}

double RandomGenerator::randf(double v) {
    float rv;
    while ((rv = (double)RandomGenerator::random() / RAND_MAX * v) &gt;= v)
        ;                                   // never return v!
    return rv;
}

double RandomGenerator::randf(double u, double v) {
    return u + RandomGenerator::randf(v-u);
}

//-----------------------------------------------------------------------
//        
// Copyright (C) 2002 Michael Ringgaard. All rights reserved.
// Copyright (C) 1983, 1993 The Regents of the University of California.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright 
//    notice, this list of conditions and the following disclaimer.  
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.  
// 3. Neither the name of the project nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission. 
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
// SUCH DAMAGE.
// 

//**#include &lt;os.h&gt;

//
// An improved random number generation package.  In addition to the standard
// rand()/srand() like interface, this package also has a special state info
// interface.  The initstate() routine is called with a seed, an array of
// bytes, and a count of how many bytes are being passed in; this array is
// then initialized to contain information for random number generation with
// that much state information.  Good sizes for the amount of state
// information are 32, 64, 128, and 256 bytes.  The state can be switched by
// calling the setstate() routine with the same array as was initiallized
// with initstate().  By default, the package runs with 128 bytes of state
// information and generates far better random numbers than a linear
// congruential generator.  If the amount of state information is less than
// 32 bytes, a simple linear congruential R.N.G. is used.
//
// Internally, the state information is treated as an array of longs; the
// zeroeth element of the array is the type of R.N.G. being used (small
// integer); the remainder of the array is the state information for the
// R.N.G.  Thus, 32 bytes of state information will give 7 longs worth of
// state information, which will allow a degree seven polynomial.  (Note:
// the zeroeth word of state information also has some other information
// stored in it -- see setstate() for details).
//
// The random number generation technique is a linear feedback shift register
// approach, employing trinomials (since there are fewer terms to sum up that
// way).  In this approach, the least significant bit of all the numbers in
// the state table will act as a linear feedback shift register, and will
// have period 2^deg - 1 (where deg is the degree of the polynomial being
// used, assuming that the polynomial is irreducible and primitive).  The
// higher order bits will have longer periods, since their values are also
// influenced by pseudo-random carries out of the lower bits.  The total
// period of the generator is approximately deg*(2**deg - 1); thus doubling
// the amount of state information has a vast influence on the period of the
// generator.  Note: the deg*(2**deg - 1) is an approximation only good for
// large deg, when the period of the shift is the dominant factor.
// With deg equal to seven, the period is actually much longer than the
// 7*(2**7 - 1) predicted by this formula.
//
// Modified 28 December 1994 by Jacob S. Rosenberg.
//

//
// For each of the currently supported random number generators, we have a
// break value on the amount of state information (you need at least this
// many bytes of state info to support this random number generator), a degree
// for the polynomial (actually a trinomial) that the R.N.G. is based on, and
// the separation between the two lower order coefficients of the trinomial.

void RandomGenerator::initialize() {

#define NSHUFF 100      // To drop part of seed -&gt; 1st value correlation

//static long degrees[MAX_TYPES] = { DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 };
//static long seps [MAX_TYPES] = { SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 };

    degrees[0] = DEG_0;
    degrees[1] = DEG_1;
    degrees[2] = DEG_2;
    degrees[3] = DEG_3;
    degrees[4] = DEG_4;

    seps [0] = SEP_0;
    seps [1] = SEP_1;
    seps [2] = SEP_2;
    seps [3] = SEP_3;
    seps [4] = SEP_4;

//
// Initially, everything is set up as if from:
//
//  initstate(1, randtbl, 128);
//
// Note that this initialization takes advantage of the fact that srandom()
// advances the front and rear pointers 10*rand_deg times, and hence the
// rear pointer which starts at 0 will also end up at zero; thus the zeroeth
// element of the state information, which contains info about the current
// position of the rear pointer is just
//
//  MAX_TYPES * (rptr - state) + TYPE_3 == TYPE_3.

    randtbl[ 0] =  TYPE_3;
    randtbl[ 1] =  0x991539b1;
    randtbl[ 2] =  0x16a5bce3;
    randtbl[ 3] =  0x6774a4cd;
    randtbl[ 4] =  0x3e01511e;
    randtbl[ 5] =  0x4e508aaa;
    randtbl[ 6] =  0x61048c05;
    randtbl[ 7] =  0xf5500617;
    randtbl[ 8] =  0x846b7115;
    randtbl[ 9] =  0x6a19892c;
    randtbl[10] =  0x896a97af;
    randtbl[11] =  0xdb48f936;
    randtbl[12] =  0x14898454;
    randtbl[13] =  0x37ffd106;
    randtbl[14] =  0xb58bff9c;
    randtbl[15] =  0x59e17104;
    randtbl[16] =  0xcf918a49;
    randtbl[17] =  0x09378c83;
    randtbl[18] =  0x52c7a471;
    randtbl[19] =  0x8d293ea9;
    randtbl[20] =  0x1f4fc301;
    randtbl[21] =  0xc3db71be;
    randtbl[22] =  0x39b44e1c;
    randtbl[23] =  0xf8a44ef9;
    randtbl[24] =  0x4c8b80b1;
    randtbl[25] =  0x19edc328;
    randtbl[26] =  0x87bf4bdd;
    randtbl[27] =  0xc9b240e5;
    randtbl[28] =  0xe9ee4b1b;
    randtbl[29] =  0x4382aee7;
    randtbl[30] =  0x535b6b41;
    randtbl[31] =  0xf3bec5da;

// static long randtbl[DEG_3 + 1] = 
// {
//   TYPE_3;
//   0x991539b1, 0x16a5bce3, 0x6774a4cd, 0x3e01511e, 0x4e508aaa, 0x61048c05,
//   0xf5500617, 0x846b7115, 0x6a19892c, 0x896a97af, 0xdb48f936, 0x14898454,
//   0x37ffd106, 0xb58bff9c, 0x59e17104, 0xcf918a49, 0x09378c83, 0x52c7a471,
//   0x8d293ea9, 0x1f4fc301, 0xc3db71be, 0x39b44e1c, 0xf8a44ef9, 0x4c8b80b1,
//   0x19edc328, 0x87bf4bdd, 0xc9b240e5, 0xe9ee4b1b, 0x4382aee7, 0x535b6b41,
//   0xf3bec5da
// };


//
// fptr and rptr are two pointers into the state info, a front and a rear
// pointer.  These two pointers are always rand_sep places aparts, as they
// cycle cyclically through the state information.  (Yes, this does mean we
// could get away with just one pointer, but the code for random() is more
// efficient this way).  The pointers are left positioned as they would be
// from the call
//
//  initstate(1, randtbl, 128);
//
// (The position of the rear pointer, rptr, is really 0 (as explained above
// in the initialization of randtbl) because the state table pointer is set
// to point to randtbl[1] (as explained below).
//

    fptr = &amp;randtbl[SEP_3 + 1];
    rptr = &amp;randtbl[1];

//
// The following things are the pointer to the state information table, the
// type of the current generator, the degree of the current polynomial being
// used, and the separation between the two pointers.  Note that for efficiency
// of random(), we remember the first location of the state information, not
// the zeroeth.  Hence it is valid to access state[-1], which is used to
// store the type of the R.N.G.  Also, we remember the last location, since
// this is more efficient than indexing every time to find the address of
// the last element to see if the front and rear pointers have wrapped.
//

    state = &amp;randtbl[1];
    rand_type = TYPE_3;
    rand_deg = DEG_3;
    rand_sep = SEP_3;
    end_ptr = &amp;randtbl[DEG_3 + 1];

}

//
// Compute x = (7^5 * x) mod (2^31 - 1)
// wihout overflowing 31 bits:
//      (2^31 - 1) = 127773 * (7^5) + 2836
// From &quot;Random number generators: good ones are hard to find&quot;,
// Park and Miller, Communications of the ACM, vol. 31, no. 10,
// October 1988, p. 1195.
//

__inline static long good_rand(long x)
{
  long hi, lo;

  // Can't be initialized with 0, so use another value.
  if (x == 0) x = 123459876;
  hi = x / 127773;
  lo = x % 127773;
  x = 16807 * lo - 2836 * hi;
  if (x &lt; 0) x += 0x7fffffff;
  return x;
}

//
// srandom
//
// Initialize the random number generator based on the given seed.  If the
// type is the trivial no-state-information type, just remember the seed.
// Otherwise, initializes state[] based on the given &quot;seed&quot; via a linear
// congruential generator.  Then, the pointers are set to known locations
// that are exactly rand_sep places apart.  Lastly, it cycles the state
// information a given number of times to get rid of any initial dependencies
// introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
// for default usage relies on values produced by this routine.

void RandomGenerator::srandom(unsigned long x)
{
  long i, lim;

  state[0] = x;
  if (rand_type == TYPE_0)
    lim = NSHUFF;
  else 
  {
    for (i = 1; i &lt; rand_deg; i++) state[i] = good_rand(state[i - 1]);
    fptr = &amp;state[rand_sep];
    rptr = &amp;state[0];
    lim = 10 * rand_deg;
  }

  initialized = 1;
  for (i = 0; i &lt; lim; i++) random();
}

#ifdef NOT_FOR_SUPERTUX     // use in supertux doesn't require these methods,
                            // which are not portable to as many platforms as
                            // SDL.  The cost is that the variability of the
                            // initial seed is reduced to only 32 bits of
                            // randomness, seemingly enough. PAK 060420
//
// srandomdev
//
// Many programs choose the seed value in a totally predictable manner.
// This often causes problems.  We seed the generator using the much more
// secure random() interface.  Note that this particular seeding
// procedure can generate states which are impossible to reproduce by
// calling srandom() with any value, since the succeeding terms in the
// state buffer are no longer derived from the LC algorithm applied to
// a fixed seed.

void RandomGenerator::srandomdev()
{
  int fd, done;
  size_t len;

  if (rand_type == TYPE_0)
    len = sizeof state[0];
  else
    len = rand_deg * sizeof state[0];

  done = 0;
  fd = open(&quot;/dev/urandom&quot;, O_RDONLY);
  if (fd &gt;= 0) 
   {
     if (read(fd, state, len) == len) done = 1;
     close(fd);
   }

  if (!done) 
  {
    struct timeval tv;

    gettimeofday(&amp;tv, NULL);
    srandom(tv.tv_sec ^ tv.tv_usec);
    return;
  }

  if (rand_type != TYPE_0) 
  {
    fptr = &amp;state[rand_sep];
    rptr = &amp;state[0];
  }
  initialized = 1;
}

//
// initstate
//
// Initialize the state information in the given array of n bytes for future
// random number generation.  Based on the number of bytes we are given, and
// the break values for the different R.N.G.'s, we choose the best (largest)
// one we can and set things up for it.  srandom() is then called to
// initialize the state information.
//
// Note that on return from srandom(), we set state[-1] to be the type
// multiplexed with the current value of the rear pointer; this is so
// successive calls to initstate() won't lose this information and will be
// able to restart with setstate().
//
// Note: the first thing we do is save the current state, if any, just like
// setstate() so that it doesn't matter when initstate is called.
//
// Returns a pointer to the old state.
//

char * RandomGenerator::initstate(unsigned long seed, char *arg_state, long n)
{
  char *ostate = (char *) (&amp;state[-1]);
  long *long_arg_state = (long *) arg_state;

  if (rand_type == TYPE_0)
    state[-1] = rand_type;
  else
    state[-1] = MAX_TYPES * (rptr - state) + rand_type;

  if (n &lt; BREAK_0) return NULL;

  if (n &lt; BREAK_1) 
  {
    rand_type = TYPE_0;
    rand_deg = DEG_0;
    rand_sep = SEP_0;
  } 
  else if (n &lt; BREAK_2) 
  {
    rand_type = TYPE_1;
    rand_deg = DEG_1;
    rand_sep = SEP_1;
  } 
  else if (n &lt; BREAK_3) 
  {
    rand_type = TYPE_2;
    rand_deg = DEG_2;
    rand_sep = SEP_2;
  } 
  else if (n &lt; BREAK_4) 
  {
    rand_type = TYPE_3;
    rand_deg = DEG_3;
    rand_sep = SEP_3;
  } 
  else 
  {
    rand_type = TYPE_4;
    rand_deg = DEG_4;
    rand_sep = SEP_4;
  }
  
  state = (long *) (long_arg_state + 1); // First location
  end_ptr = &amp;state[rand_deg]; // Must set end_ptr before srandom
  srandom(seed);

  if (rand_type == TYPE_0)
    long_arg_state[0] = rand_type;
  else
    long_arg_state[0] = MAX_TYPES * (rptr - state) + rand_type;

  initialized = 1;
  return ostate;
}

//
// setstate
//
// Restore the state from the given state array.
//
// Note: it is important that we also remember the locations of the pointers
// in the current state information, and restore the locations of the pointers
// from the old state information.  This is done by multiplexing the pointer
// location into the zeroeth word of the state information.
//
// Note that due to the order in which things are done, it is OK to call
// setstate() with the same state as the current state.
//
// Returns a pointer to the old state information.
//

char * RandomGenerator::setstate(char *arg_state)
{
  long *new_state = (long *) arg_state;
  long type = new_state[0] % MAX_TYPES;
  long rear = new_state[0] / MAX_TYPES;
  char *ostate = (char *) (&amp;state[-1]);

  if (rand_type == TYPE_0)
    state[-1] = rand_type;
  else
    state[-1] = MAX_TYPES * (rptr - state) + rand_type;

  switch(type) 
  {
    case TYPE_0:
    case TYPE_1:
    case TYPE_2:
    case TYPE_3:
    case TYPE_4:
      rand_type = type;
      rand_deg = degrees[type];
      rand_sep = seps[type];
      break;
  }

  state = (long *) (new_state + 1);
  if (rand_type != TYPE_0) 
  {
    rptr = &amp;state[rear];
    fptr = &amp;state[(rear + rand_sep) % rand_deg];
  }
  end_ptr = &amp;state[rand_deg];   // Set end_ptr too

  initialized = 1;
  return ostate;
}
#endif //NOT_FOR_SUPERTUX
//
// random:
//
// If we are using the trivial TYPE_0 R.N.G., just do the old linear
// congruential bit.  Otherwise, we do our fancy trinomial stuff, which is
// the same in all the other cases due to all the global variables that have
// been set up.  The basic operation is to add the number at the rear pointer
// into the one at the front pointer.  Then both pointers are advanced to
// the next location cyclically in the table.  The value returned is the sum
// generated, reduced to 31 bits by throwing away the &quot;least random&quot; low bit.
//
// Note: the code takes advantage of the fact that both the front and
// rear pointers can't wrap on the same call by not testing the rear
// pointer if the front one has wrapped.
//
// Returns a 31-bit random number.
//

long RandomGenerator::random()
{
  long i;
  long *f, *r;
  if (!initialized) {
      throw std::runtime_error(&quot;uninitialized RandomGenerator object&quot;);
  }

  if (rand_type == TYPE_0) 
  {
    i = state[0];
    state[0] = i = (good_rand(i)) &amp; 0x7fffffff;
  } 
  else 
  {
    f = fptr; r = rptr;
    *f += *r;
    i = (*f &gt;&gt; 1) &amp; 0x7fffffff; // Chucking least random bit
    if (++f &gt;= end_ptr) 
    {
      f = state;
      ++r;
    }
    else if (++r &gt;= end_ptr) 
      r = state;

    fptr = f; rptr = r;
  }

  return i;
}
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000183.html">[Supertux-devel] dev version bug
</A></li>
	<LI>Next message: <A HREF="000173.html">[Supertux-devel] Snow appearance
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#187">[ date ]</a>
              <a href="thread.html#187">[ thread ]</a>
              <a href="subject.html#187">[ subject ]</a>
              <a href="author.html#187">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/supertux-devel">More information about the Supertux-devel
mailing list</a><br>
</body></html>
