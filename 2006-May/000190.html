<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Supertux-devel] dev version bug
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/supertux-devel/2006-May/index.html" >
   <LINK REL="made" HREF="mailto:supertux-devel%40lists.berlios.de?Subject=Re%3A%20%5BSupertux-devel%5D%20dev%20version%20bug&In-Reply-To=%3C4456055E.50302%40a-king.us%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000189.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Supertux-devel] dev version bug</H1>
    <B>Allen King</B> 
    <A HREF="mailto:supertux-devel%40lists.berlios.de?Subject=Re%3A%20%5BSupertux-devel%5D%20dev%20version%20bug&In-Reply-To=%3C4456055E.50302%40a-king.us%3E"
       TITLE="[Supertux-devel] dev version bug">allen at a-king.us
       </A><BR>
    <I>Mon May  1 14:55:58 CEST 2006</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000189.html">[Supertux-devel] Infoboxes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#190">[ date ]</a>
              <a href="thread.html#190">[ thread ]</a>
              <a href="subject.html#190">[ subject ]</a>
              <a href="author.html#190">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Joth,
    Mission accomplished -- grats!  Your test exposed a flaw in my thinking

Ryan,
    In going to an architecture-independent random number 
implementation, I was still using the architecture-dependent variable 
RAND_MAX.  In Joth's setup, apparently RAND_MAX was 0x7fff, and not 
equal to INT_MAX (which was 0x7fffffff, since the program passed an 
assert(sizeof(int) &gt;= 4); )

    This insight exposes an error the patch will induce in the 
randf(...) routines -- they will produce numbers 65,536.0 times too big!

    Attached is a RandomGenerator.patch3b fixes this problem, and also 
contains all of the changes in RandomPatch.3, since r3478 seemed to have 
none of them yet.

Joth Esmo wrote:
&gt;<i> Greetings,
</I>&gt;<i>
</I>&gt;<i> Thanks for clearing everything up. Attached is random_generator.cpp
</I>&gt;<i> with the stderr file. In case you can't access it, here's the
</I>&gt;<i> important stuff:
</I>&gt;<i>
</I>&gt;<i> ==== srand(1146426740) (         0) RAND_MAX=7fff =====
</I>&gt;<i> ERROR: x=44551574, x0=0, RAND_MAX=7fff
</I>&gt;<i> Assertion failed: 0, file src/random_generator.cpp, line 77
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Joth
</I>&gt;<i>
</I>&gt;<i> On 4/29/06, Allen King &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/supertux-devel">allen at a-king.us</A>&gt; wrote:
</I>&gt;&gt;<i> Joth,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Thanks for getting back to me so quickly, and with all the right 
</I>&gt;&gt;<i> data.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There may have been a mis-understanding. The experiment I'm asking 
</I>&gt;&gt;<i> you to do
</I>&gt;&gt;<i> is not to fix your problem, but to produce additional output in the 
</I>&gt;&gt;<i> failing
</I>&gt;&gt;<i> mode that will help me isolate another suspected related problem.  
</I>&gt;&gt;<i> (Below, I
</I>&gt;&gt;<i> will tell you how to get the code to work, but not here.)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So here are some points I want to make very clear. (Sorry if this is
</I>&gt;&gt;<i> obvious, and I'm being blunt.):
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The newer version of the RandomGenerator::srand method code I sent 
</I>&gt;&gt;<i> you also
</I>&gt;&gt;<i> fail.  I want it to.  As such, that line 72 of random_generator.cpp (the
</I>&gt;&gt;<i> &quot;assert(0);&quot;) fails is not a problem for this test, it is good.
</I>&gt;&gt;<i> Line 68 should be of a form &quot;if (x &lt; RAND_MAX)&quot; to duplicate the 
</I>&gt;&gt;<i> failure.
</I>&gt;&gt;<i> In particular, it should not be modified to &quot;if (x &lt;= RAND_MAX)&quot;, or the
</I>&gt;&gt;<i> failure may change or perhaps go away.  ACTION: change line 68 from &quot;&lt;=&quot;
</I>&gt;&gt;<i> back to &quot;&lt;&quot;, so the failure will be replicated.
</I>&gt;&gt;<i> I see no line like &quot;==== srand(ddd) (ddd) RAND_MAX=xxx =====&quot; (where ddd
</I>&gt;&gt;<i> (xxx) are some decimal (hex) numbers) in your console output.  QUESTION:
</I>&gt;&gt;<i> Double and tripple check. Did you perhaps not compile the changes, or 
</I>&gt;&gt;<i> not
</I>&gt;&gt;<i> use the patched version when making the new console output?
</I>&gt;&gt;<i> If the above gets you lines like &quot;=====....&quot; above in the console 
</I>&gt;&gt;<i> output,
</I>&gt;&gt;<i> you're done, send be back the console and random_generator.cpp, and 
</I>&gt;&gt;<i> ignore
</I>&gt;&gt;<i> this.  If still no such lines appear, I'm wondering if your console 
</I>&gt;&gt;<i> log is
</I>&gt;&gt;<i> only monitoring things to standard error.  To get these printouts 
</I>&gt;&gt;<i> also on
</I>&gt;&gt;<i> standard error, try changing the string &quot;printf(&quot; to &quot;fprintf(stderr, 
</I>&gt;&gt;<i> &quot;, in
</I>&gt;&gt;<i> lines 67 and 71.  (You may or may not need to add a &quot;#include &lt;stdio.h&gt;&quot;
</I>&gt;&gt;<i> line to compile properly.) At this point, the routine in question should
</I>&gt;&gt;<i> look like the following:
</I>&gt;&gt;<i> #include &lt;stdio.h&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;&gt;<i>     int x0 = x;
</I>&gt;&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;&gt;<i>     fprintf(stderr, &quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, 
</I>&gt;&gt;<i> x0,
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     if (x &lt; RAND_MAX) {
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     else {                                  // only allow
</I>&gt;&gt;<i> posative 31-bit seeds
</I>&gt;&gt;<i>         fprintf(stderr, &quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0,
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         assert(0);
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;&gt;<i>     return x;                               // let caller
</I>&gt;&gt;<i> know seed used
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> When you get the line with the &quot;====...&quot; in it, send me back the same 
</I>&gt;&gt;<i> stuff
</I>&gt;&gt;<i> as before, except don't bother with the config file -- it's good.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you can't get the &quot;====...&quot; line, try commenting out the assert(0) 
</I>&gt;&gt;<i> above,
</I>&gt;&gt;<i> and replace the following routine:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> int RandomGenerator::rand(int v) {
</I>&gt;&gt;<i>     assert(v != 0 &amp;&amp; v &lt;= RAND_MAX);
</I>&gt;&gt;<i>     int rv = RandomGenerator::random();
</I>&gt;&gt;<i>     printf(&quot;===x= rand(%10d) (%10d) RAND_MAX=%x =x====\n&quot;, v, rv, 
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>     fprintf(stderr, &quot;==== rand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, v, rv,
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>     return rv % v;
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Short of that, can I have VNC  access to your machine?  Hopefully it 
</I>&gt;&gt;<i> won't
</I>&gt;&gt;<i> get to that!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     Allen
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> P.S.:  To run supertux, use the origional code (without any of the 
</I>&gt;&gt;<i> mods I've
</I>&gt;&gt;<i> been feeding to you for debug), and comment out the 
</I>&gt;&gt;<i> &quot;assert(x&lt;RAND_MAX);&quot;
</I>&gt;&gt;<i> line.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Joth Esmo wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;&gt;<i>     int x0 = x;
</I>&gt;&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;&gt;<i>     fprintf(stderr, &quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, 
</I>&gt;&gt;<i> x0,
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     if (x &lt; RAND_MAX) {
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     else {                                  // only allow
</I>&gt;&gt;<i> posative 31-bit seeds
</I>&gt;&gt;<i>         fprintf(stderr, &quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0,
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         assert(0);
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;&gt;<i>     return x;                               // let caller
</I>&gt;&gt;<i> know seed used
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> When you get the line with the &quot;====...&quot; in it, send me back the same 
</I>&gt;&gt;<i> stuff
</I>&gt;&gt;<i> as before, except don't bother with the config file -- it's good.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you can't get the &quot;====...&quot; line, try commenting out the assert(0) 
</I>&gt;&gt;<i> above,
</I>&gt;&gt;<i> and replace the following routine:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> int RandomGenerator::rand(int v) {
</I>&gt;&gt;<i>     assert(v != 0 &amp;&amp; v &lt;= RAND_MAX);
</I>&gt;&gt;<i>     int rv = RandomGenerator::random();
</I>&gt;&gt;<i>     printf(&quot;===x= rand(%10d) (%10d) RAND_MAX=%x =x====\n&quot;, v, rv, 
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>     fprintf(stderr, &quot;==== rand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, v, rv,
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>     return rv % v;
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Short of that, can I have VNC  access to your machine?  Hopefully it 
</I>&gt;&gt;<i> won't
</I>&gt;&gt;<i> get to that!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     Allen
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> P.S.:  To run supertux, use the origional code (without any of the 
</I>&gt;&gt;<i> mods I've
</I>&gt;&gt;<i> been feeding to you for debug), and comment out the 
</I>&gt;&gt;<i> &quot;assert(x&lt;RAND_MAX);&quot;
</I>&gt;&gt;<i> line.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Joth Esmo wrote:
</I>&gt;&gt;<i> I replaced the text in the .cpp file as you asked and compiled. The
</I>&gt;&gt;<i> error log (stderr) is attached. Line 72 of random_generator.cpp seems
</I>&gt;&gt;<i> to be the problem (the line being: assert(0);). Also attached is my
</I>&gt;&gt;<i> ./supertux/config file. I start the application by opening MSYS,
</I>&gt;&gt;<i> navigating to my supertux directory, and issuing the command
</I>&gt;&gt;<i> 'supertux.exe -w' (as per the Building on Windows page on the wiki --
</I>&gt;&gt;<i> however the -w has been recently removed).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In your email, you asked for the patched version of random_seed.cpp. I
</I>&gt;&gt;<i> assume you meant random_generator.cpp, which is attached.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not sure what you mean by 'capable of debug'. Should I debug it
</I>&gt;&gt;<i> and then watch the value of the config variable? I didn't quite
</I>&gt;&gt;<i> understand your meaning.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> PS&gt; I changed the text in random_generator.cpp to read : x &lt;= RAND_MAX
</I>&gt;&gt;<i> (as you requested).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Regards,
</I>&gt;&gt;<i> Joth
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On 4/29/06, Allen King &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/supertux-devel">allen at a-king.us</A>&gt; wrote:
</I>&gt;&gt;<i> Joth,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A new patch to fix that problem is in the works, and should be in svn
</I>&gt;&gt;<i> shortly.  Should have been x &lt;= RAND_MAX. For the moment, that line 
</I>&gt;&gt;<i> can be
</I>&gt;&gt;<i> commented out, or the &lt; changed to &lt;= .
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> But the fact that this problem happened at all is curious to me, and I
</I>&gt;&gt;<i> suspect another bug lurking nearby.  In particular, I would like to
</I>&gt;&gt;<i> understand what about your XP setup caused that assertion error.  If
</I>&gt;&gt;<i> RAND_MAX is 0x7fffffff, the largest int32, it would be improbably that
</I>&gt;&gt;<i> time(0) would generate that (unless it's not working).  Or perhaps 
</I>&gt;&gt;<i> RAND_MAX
</I>&gt;&gt;<i> is smaller.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you can patch to the source code, would you replace the routine in
</I>&gt;&gt;<i> random_generator.cpp with
</I>&gt;&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;&gt;<i>     int x0 = x;
</I>&gt;&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;&gt;<i>     printf(&quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, x0, 
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;&gt;<i>     if (x &lt; RAND_MAX) {
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     else {                                  // only allow
</I>&gt;&gt;<i> posative 31-bit
</I>&gt;&gt;<i> seeds
</I>&gt;&gt;<i>         printf(&quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0, RAND_MAX);
</I>&gt;&gt;<i>         assert(0);
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;&gt;<i>     return x;                               // let caller
</I>&gt;&gt;<i> know seed used
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i> and recreate the failure.  Send me the command line used to invoke 
</I>&gt;&gt;<i> supertux,
</I>&gt;&gt;<i> the failing printout (as you did), a copy of your ~/.supertux/config 
</I>&gt;&gt;<i> file,
</I>&gt;&gt;<i> and the patched copy of random_seed.cpp.  If you are you capable of 
</I>&gt;&gt;<i> debug,
</I>&gt;&gt;<i> the variable config-&gt;random_seed should be traced.  Is it RAND_MAX at 
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> assertion failure?  Who sets it that?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks for your help on this.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>        Allen
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Jonathan Campbell wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Greetings I just finished compiling the development version of 
</I>&gt;&gt;<i> SuperTux (the
</I>&gt;&gt;<i> newest build) and tried to launch it. However, it quits after showing a
</I>&gt;&gt;<i> transparent window. The file stderr has the following: [INFO]
</I>&gt;&gt;<i> src/main.cpp:195 [C:\Documents and
</I>&gt;&gt;<i> Settings\Administrator\.supertux] is in the search path
</I>&gt;&gt;<i> [INFO] src/main.cpp:195 [c:\msys\1.0\build\supertux\/data]
</I>&gt;&gt;<i> is in the search path [INFO] src/main.cpp:429 Component 'controller'
</I>&gt;&gt;<i> finished after 0.2 seconds [INFO] src/main.cpp:68 Couldn't load 
</I>&gt;&gt;<i> config file:
</I>&gt;&gt;<i> Couldn't open file 'config': The system cannot find the file 
</I>&gt;&gt;<i> specified. ,
</I>&gt;&gt;<i> using default settings [INFO] src/main.cpp:429 Component 'config' 
</I>&gt;&gt;<i> finished
</I>&gt;&gt;<i> after 0 seconds [INFO] src/main.cpp:429 Component 'tinygettext' finished
</I>&gt;&gt;<i> after 0.001 seconds [INFO] src/main.cpp:429 Component 'commandline' 
</I>&gt;&gt;<i> finished
</I>&gt;&gt;<i> after 0 seconds [INFO] src/main.cpp:429 Component 'audio' finished after
</I>&gt;&gt;<i> 0.202 seconds [INFO] src/main.cpp:429 Component 'video' finished 
</I>&gt;&gt;<i> after 0.278
</I>&gt;&gt;<i> seconds [INFO] src/main.cpp:429 Component 'scripting' finished after 
</I>&gt;&gt;<i> 0.005
</I>&gt;&gt;<i> seconds [DEBUG] src/tile_manager.cpp:47 Tiles loaded in 0.059 seconds 
</I>&gt;&gt;<i> [INFO]
</I>&gt;&gt;<i> src/main.cpp:429 Component 'resources' finished after 0.236 seconds
</I>&gt;&gt;<i> Assertion failed: x &lt; RAND_MAX, file src/random_generator.cpp, line 
</I>&gt;&gt;<i> 57 I'm
</I>&gt;&gt;<i> running Windows XP with all updates installed. To compile it, I 
</I>&gt;&gt;<i> followed the
</I>&gt;&gt;<i> instructions on this page on the wiki:
</I>&gt;&gt;<i> <A HREF="http://supertux.berlios.de/wiki/index.php/Building_on_Windows">http://supertux.berlios.de/wiki/index.php/Building_on_Windows</A>
</I>&gt;&gt;<i> Any help would be appreciated. I'd really like to see this new 
</I>&gt;&gt;<i> version of
</I>&gt;&gt;<i> SuperTux. Regards, Joth Esmo
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Supertux-devel mailing list <A HREF="https://lists.berlios.de/mailman/listinfo/supertux-devel">Supertux-devel at lists.berlios.de</A>
</I>&gt;&gt;<i> <A HREF="http://lists.berlios.de/mailman/listinfo/supertux-devel">http://lists.berlios.de/mailman/listinfo/supertux-devel</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> -- 
</I>&gt;&gt;<i> Flarbland: Your one and only stop for cheats, articles, comedy and
</I>&gt;&gt;<i> much, much more!
</I>&gt;&gt;<i> <A HREF="http://flarbland.bravehost.com">http://flarbland.bravehost.com</A>
</I>&gt;&gt;<i> ________________________________
</I>&gt;&gt;<i>
</I>&gt;<i> [INFO] src/main.cpp:195 [C:\Documents and
</I>&gt;&gt;<i> Settings\HP_Administrator\.supertux] is in the search
</I>&gt;&gt;<i> path
</I>&gt;<i> [INFO] src/main.cpp:195
</I>&gt;&gt;<i> [c:\msys\1.0\build\supertux2\/data] is in the search
</I>&gt;&gt;<i> path
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'controller' finished after 0.2
</I>&gt;&gt;<i> seconds
</I>&gt;<i> [WARNING]
</I>&gt;&gt;<i> src/control/joystickkeyboardcontroller.cpp:192 Invalid
</I>&gt;&gt;<i> button '0' in buttonmap
</I>&gt;<i> [WARNING]
</I>&gt;&gt;<i> src/control/joystickkeyboardcontroller.cpp:192 Invalid
</I>&gt;&gt;<i> button '1' in buttonmap
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'config' finished
</I>&gt;&gt;<i> after 0.021 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'tinygettext' finished
</I>&gt;&gt;<i> after 0 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'commandline' finished
</I>&gt;&gt;<i> after 0 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'audio' finished after
</I>&gt;&gt;<i> 0.302 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'video' finished after 0.432
</I>&gt;&gt;<i> seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'scripting' finished after 0.034
</I>&gt;&gt;<i> seconds
</I>&gt;<i> [DEBUG] src/tile_manager.cpp:47 Tiles loaded in 0.057 seconds
</I>&gt;<i> [INFO]
</I>&gt;&gt;<i> src/main.cpp:429 Component 'resources' finished after 0.217
</I>&gt;&gt;<i> seconds
</I>&gt;<i> Assertion failed: 0, file src/random_generator.cpp, line 72
</I>&gt;<i>
</I>&gt;<i> This
</I>&gt;&gt;<i> application has requested the Runtime to terminate it in an unusual
</I>&gt;&gt;<i> way.
</I>&gt;<i> Please contact the application's support team for more
</I>&gt;&gt;<i> information.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> ________________________________
</I>&gt;&gt;<i>
</I>&gt;<i> (supertux-config
</I>&gt;<i> (show_fps #f)
</I>&gt;<i> (cheats #f)
</I>&gt;<i> (video
</I>&gt;<i> (fullscreen #t)
</I>&gt;&gt;<i> (width 800)
</I>&gt;<i> (height 600)
</I>&gt;<i> )
</I>&gt;<i> (audio
</I>&gt;<i> (sound_enabled #t)
</I>&gt;<i> (music_enabled
</I>&gt;&gt;<i> #t)
</I>&gt;<i> )
</I>&gt;<i> (control
</I>&gt;<i> (keymap
</I>&gt;<i> (map
</I>&gt;<i> (key 13)
</I>&gt;<i> (control &quot;menu-select&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;&gt;<i> (key 19)
</I>&gt;<i> (control &quot;pause-menu&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key 27)
</I>&gt;<i> (control &quot;pause-menu&quot;)
</I>&gt;&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key 94)
</I>&gt;<i> (control &quot;console&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key 112)
</I>&gt;<i> (control
</I>&gt;&gt;<i> &quot;pause-menu&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key 271)
</I>&gt;<i> (control &quot;menu-select&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key
</I>&gt;&gt;<i> 273)
</I>&gt;<i> (control &quot;jump&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key 274)
</I>&gt;<i> (control &quot;down&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key
</I>&gt;&gt;<i> 275)
</I>&gt;<i> (control &quot;right&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key 276)
</I>&gt;<i> (control &quot;left&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key
</I>&gt;&gt;<i> 303)
</I>&gt;<i> (control &quot;up&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (key 304)
</I>&gt;<i> (control &quot;action&quot;)
</I>&gt;<i> )
</I>&gt;<i> )
</I>&gt;&gt;<i> (joystick
</I>&gt;<i> (use_hat #t)
</I>&gt;<i> (axis_x 0)
</I>&gt;<i> (axis_y 1)
</I>&gt;<i> (dead_zone_x 1000)
</I>&gt;&gt;<i> (dead_zone_y 1000)
</I>&gt;<i> (map
</I>&gt;<i> (button 0)
</I>&gt;<i> (control &quot;jump&quot;)
</I>&gt;<i> )
</I>&gt;<i> (map
</I>&gt;<i> (button 1)
</I>&gt;&gt;<i> (control &quot;action&quot;)
</I>&gt;<i> )
</I>&gt;<i> )
</I>&gt;<i> )
</I>&gt;<i> )
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> ________________________________
</I>&gt;&gt;<i>
</I>&gt;<i> // $Id: random_generator.cpp 3435 2006-04-26 02:13:42Z sik0fewl $
</I>&gt;<i> //
</I>&gt;<i> // A
</I>&gt;&gt;<i> strong random number generator
</I>&gt;<i> //
</I>&gt;<i> // Copyright (C) 2006 Allen King
</I>&gt;<i> //
</I>&gt;&gt;<i> Copyright (C) 2002 Michael Ringgaard. All rights reserved.
</I>&gt;<i> // Copyright (C)
</I>&gt;&gt;<i> 1983, 1993 The Regents of the University of California.
</I>&gt;<i> //
</I>&gt;<i> // Redistribution
</I>&gt;&gt;<i> and use in source and binary forms, with or without
</I>&gt;<i> // modification, are
</I>&gt;&gt;<i> permitted provided that the following conditions
</I>&gt;<i> // are met:
</I>&gt;<i> //
</I>&gt;<i> // 1.
</I>&gt;&gt;<i> Redistributions of source code must retain the above copyright
</I>&gt;<i> // notice,
</I>&gt;&gt;<i> this list of conditions and the following disclaimer.
</I>&gt;<i> // 2. Redistributions
</I>&gt;&gt;<i> in binary form must reproduce the above copyright
</I>&gt;<i> // notice, this list of
</I>&gt;&gt;<i> conditions and the following disclaimer in the
</I>&gt;<i> // documentation and/or other
</I>&gt;&gt;<i> materials provided with the distribution.
</I>&gt;<i> // 3. Neither the name of the
</I>&gt;&gt;<i> project nor the names of its contributors
</I>&gt;<i> // may be used to endorse or
</I>&gt;&gt;<i> promote products derived from this software
</I>&gt;<i> // without specific prior
</I>&gt;&gt;<i> written permission.
</I>&gt;<i> //
</I>&gt;<i> // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
</I>&gt;&gt;<i> HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</I>&gt;<i> // ANY EXPRESS OR IMPLIED WARRANTIES,
</I>&gt;&gt;<i> INCLUDING, BUT NOT LIMITED TO, THE
</I>&gt;<i> // IMPLIED WARRANTIES OF MERCHANTABILITY
</I>&gt;&gt;<i> AND FITNESS FOR A PARTICULAR PURPOSE
</I>&gt;<i> // ARE DISCLAIMED. IN NO EVENT SHALL
</I>&gt;&gt;<i> THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
</I>&gt;<i> // FOR ANY DIRECT, INDIRECT,
</I>&gt;&gt;<i> INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</I>&gt;<i> // DAMAGES (INCLUDING, BUT
</I>&gt;&gt;<i> NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</I>&gt;<i> // OR SERVICES; LOSS OF USE,
</I>&gt;&gt;<i> DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</I>&gt;<i> // HOWEVER CAUSED AND ON ANY
</I>&gt;&gt;<i> THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
</I>&gt;<i> // LIABILITY, OR TORT
</I>&gt;&gt;<i> (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
</I>&gt;<i> // OUT OF THE USE OF
</I>&gt;&gt;<i> THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
</I>&gt;<i> // SUCH DAMAGE.
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;&gt;<i> Transliterated into C++ Allen King 060417, from sources on
</I>&gt;<i> //
</I>&gt;&gt;<i> <A HREF="http://www.jbox.dk/sanos/source/lib/random.c.html">http://www.jbox.dk/sanos/source/lib/random.c.html</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> #include
</I>&gt;&gt;<i> &lt;stdexcept&gt;
</I>&gt;<i> #include &quot;random_generator.hpp&quot;
</I>&gt;<i> #include
</I>&gt;&gt;<i> &quot;scripting/squirrel_util.hpp&quot;
</I>&gt;<i>
</I>&gt;<i> RandomGenerator systemRandom; // global
</I>&gt;&gt;<i> random number generator
</I>&gt;<i>
</I>&gt;<i> RandomGenerator::RandomGenerator()
</I>&gt;&gt;<i> {
</I>&gt;<i> assert(sizeof(int) &gt;= 4);
</I>&gt;<i> initialized = 0;
</I>&gt;&gt;<i> initialize();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> RandomGenerator::~RandomGenerator()
</I>&gt;&gt;<i> {
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> /*int RandomGenerator::srand(int x) {
</I>&gt;<i> while (x == 0) // random seed of
</I>&gt;&gt;<i> zero means
</I>&gt;<i> x = time(0); // randomize with time
</I>&gt;<i> assert(x &lt; RAND_MAX); //
</I>&gt;&gt;<i> only allow posative 31-bit seeds
</I>&gt;<i> assert(sizeof(int) &gt;= 4);
</I>&gt;<i> srandom(x);
</I>&gt;&gt;<i> return x; // let caller know seed used
</I>&gt;<i> }*/
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::srand(int
</I>&gt;&gt;<i> x) {
</I>&gt;<i> int x0 = x;
</I>&gt;<i> while (x == 0) // random seed of zero means
</I>&gt;<i> x = time(0);
</I>&gt;&gt;<i> // randomize with time
</I>&gt;<i> printf(&quot;==== srand(%10d) (%10d) RAND_MAX=%x
</I>&gt;&gt;<i> =====\n&quot;, x, x0, RAND_MAX);
</I>&gt;<i> if (x &lt;= RAND_MAX) {
</I>&gt;<i> }
</I>&gt;<i> else { // only allow
</I>&gt;&gt;<i> posative 31-bit seeds
</I>&gt;<i> printf(&quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0,
</I>&gt;&gt;<i> RAND_MAX);
</I>&gt;<i> assert(0);
</I>&gt;<i> }
</I>&gt;<i> RandomGenerator::srandom(x);
</I>&gt;<i> return x; // let
</I>&gt;&gt;<i> caller know seed used
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand() { return random();
</I>&gt;&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand(int v) {
</I>&gt;<i> assert(v != 0 &amp;&amp; v &lt;= RAND_MAX); //
</I>&gt;&gt;<i> illegal arg: 0 or too big
</I>&gt;<i> return RandomGenerator::random() % v;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int
</I>&gt;&gt;<i> RandomGenerator::rand(int u, int v) {
</I>&gt;<i> assert(v &gt; u);
</I>&gt;<i> return u +
</I>&gt;&gt;<i> RandomGenerator::rand(v-u);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> double RandomGenerator::randf(double v) {
</I>&gt;&gt;<i> float rv;
</I>&gt;<i> while ((rv = (double)RandomGenerator::random() /
</I>&gt;&gt;<i> RAND_MAX * v) &gt;= v)
</I>&gt;<i> ; // never return v!
</I>&gt;<i> return rv;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> double
</I>&gt;&gt;<i> RandomGenerator::randf(double u, double v) {
</I>&gt;<i> return u +
</I>&gt;&gt;<i> RandomGenerator::randf(v-u);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //-----------------------------------------------------------------------
</I>&gt;<i> //
</I>&gt;&gt;<i>
</I>&gt;<i> // Copyright (C) 2002 Michael Ringgaard. All rights reserved.
</I>&gt;<i> // Copyright
</I>&gt;&gt;<i> (C) 1983, 1993 The Regents of the University of California.
</I>&gt;<i> //
</I>&gt;<i> //
</I>&gt;&gt;<i> Redistribution and use in source and binary forms, with or without
</I>&gt;<i> //
</I>&gt;&gt;<i> modification, are permitted provided that the following conditions
</I>&gt;<i> // are
</I>&gt;&gt;<i> met:
</I>&gt;<i> //
</I>&gt;<i> // 1. Redistributions of source code must retain the above
</I>&gt;&gt;<i> copyright
</I>&gt;<i> // notice, this list of conditions and the following disclaimer.
</I>&gt;&gt;<i>
</I>&gt;<i> // 2. Redistributions in binary form must reproduce the above copyright
</I>&gt;<i> //
</I>&gt;&gt;<i> notice, this list of conditions and the following disclaimer in the
</I>&gt;<i> //
</I>&gt;&gt;<i> documentation and/or other materials provided with the distribution.
</I>&gt;<i> // 3.
</I>&gt;&gt;<i> Neither the name of the project nor the names of its contributors
</I>&gt;<i> // may be
</I>&gt;&gt;<i> used to endorse or promote products derived from this software
</I>&gt;<i> // without
</I>&gt;&gt;<i> specific prior written permission.
</I>&gt;<i> //
</I>&gt;<i> // THIS SOFTWARE IS PROVIDED BY THE
</I>&gt;&gt;<i> COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</I>&gt;<i> // ANY EXPRESS OR IMPLIED
</I>&gt;&gt;<i> WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
</I>&gt;<i> // IMPLIED WARRANTIES OF
</I>&gt;&gt;<i> MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
</I>&gt;<i> // ARE DISCLAIMED. IN
</I>&gt;&gt;<i> NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
</I>&gt;<i> // FOR ANY
</I>&gt;&gt;<i> DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</I>&gt;<i> //
</I>&gt;&gt;<i> DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</I>&gt;<i> //
</I>&gt;&gt;<i> OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</I>&gt;<i> //
</I>&gt;&gt;<i> HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
</I>&gt;&gt;<i> STRICT
</I>&gt;<i> // LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
</I>&gt;&gt;<i> ANY WAY
</I>&gt;<i> // OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
</I>&gt;&gt;<i> POSSIBILITY OF
</I>&gt;<i> // SUCH DAMAGE.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> //**#include &lt;os.h&gt;
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // An improved
</I>&gt;&gt;<i> random number generation package. In addition to the standard
</I>&gt;<i> //
</I>&gt;&gt;<i> rand()/srand() like interface, this package also has a special state 
</I>&gt;&gt;<i> info
</I>&gt;<i> //
</I>&gt;&gt;<i> interface. The initstate() routine is called with a seed, an array of
</I>&gt;<i> //
</I>&gt;&gt;<i> bytes, and a count of how many bytes are being passed in; this array is
</I>&gt;<i> //
</I>&gt;&gt;<i> then initialized to contain information for random number generation 
</I>&gt;&gt;<i> with
</I>&gt;<i> //
</I>&gt;&gt;<i> that much state information. Good sizes for the amount of state
</I>&gt;<i> //
</I>&gt;&gt;<i> information are 32, 64, 128, and 256 bytes. The state can be switched by
</I>&gt;<i> //
</I>&gt;&gt;<i> calling the setstate() routine with the same array as was initiallized
</I>&gt;<i> //
</I>&gt;&gt;<i> with initstate(). By default, the package runs with 128 bytes of state
</I>&gt;<i> //
</I>&gt;&gt;<i> information and generates far better random numbers than a linear
</I>&gt;<i> //
</I>&gt;&gt;<i> congruential generator. If the amount of state information is less than
</I>&gt;<i> //
</I>&gt;&gt;<i> 32 bytes, a simple linear congruential R.N.G. is used.
</I>&gt;<i> //
</I>&gt;<i> // Internally, the
</I>&gt;&gt;<i> state information is treated as an array of longs; the
</I>&gt;<i> // zeroeth element of
</I>&gt;&gt;<i> the array is the type of R.N.G. being used (small
</I>&gt;<i> // integer); the remainder
</I>&gt;&gt;<i> of the array is the state information for the
</I>&gt;<i> // R.N.G. Thus, 32 bytes of
</I>&gt;&gt;<i> state information will give 7 longs worth of
</I>&gt;<i> // state information, which
</I>&gt;&gt;<i> will allow a degree seven polynomial. (Note:
</I>&gt;<i> // the zeroeth word of state
</I>&gt;&gt;<i> information also has some other information
</I>&gt;<i> // stored in it -- see
</I>&gt;&gt;<i> setstate() for details).
</I>&gt;<i> //
</I>&gt;<i> // The random number generation technique is a
</I>&gt;&gt;<i> linear feedback shift register
</I>&gt;<i> // approach, employing trinomials (since
</I>&gt;&gt;<i> there are fewer terms to sum up that
</I>&gt;<i> // way). In this approach, the least
</I>&gt;&gt;<i> significant bit of all the numbers in
</I>&gt;<i> // the state table will act as a
</I>&gt;&gt;<i> linear feedback shift register, and will
</I>&gt;<i> // have period 2^deg - 1 (where deg
</I>&gt;&gt;<i> is the degree of the polynomial being
</I>&gt;<i> // used, assuming that the polynomial
</I>&gt;&gt;<i> is irreducible and primitive). The
</I>&gt;<i> // higher order bits will have longer
</I>&gt;&gt;<i> periods, since their values are also
</I>&gt;<i> // influenced by pseudo-random carries
</I>&gt;&gt;<i> out of the lower bits. The total
</I>&gt;<i> // period of the generator is approximately
</I>&gt;&gt;<i> deg*(2**deg - 1); thus doubling
</I>&gt;<i> // the amount of state information has a
</I>&gt;&gt;<i> vast influence on the period of the
</I>&gt;<i> // generator. Note: the deg*(2**deg - 1)
</I>&gt;&gt;<i> is an approximation only good for
</I>&gt;<i> // large deg, when the period of the shift
</I>&gt;&gt;<i> is the dominant factor.
</I>&gt;<i> // With deg equal to seven, the period is actually
</I>&gt;&gt;<i> much longer than the
</I>&gt;<i> // 7*(2**7 - 1) predicted by this formula.
</I>&gt;<i> //
</I>&gt;<i> //
</I>&gt;&gt;<i> Modified 28 December 1994 by Jacob S. Rosenberg.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // For each of the
</I>&gt;&gt;<i> currently supported random number generators, we have a
</I>&gt;<i> // break value on
</I>&gt;&gt;<i> the amount of state information (you need at least this
</I>&gt;<i> // many bytes of
</I>&gt;&gt;<i> state info to support this random number generator), a degree
</I>&gt;<i> // for the
</I>&gt;&gt;<i> polynomial (actually a trinomial) that the R.N.G. is based on, and
</I>&gt;<i> // the
</I>&gt;&gt;<i> separation between the two lower order coefficients of the trinomial.
</I>&gt;<i>
</I>&gt;<i> void
</I>&gt;&gt;<i> RandomGenerator::initialize() {
</I>&gt;<i>
</I>&gt;<i> #define NSHUFF 100 // To drop part of seed
</I>&gt;&gt;<i> -&gt; 1st value correlation
</I>&gt;<i>
</I>&gt;<i> //static long degrees[MAX_TYPES] = { DEG_0, DEG_1,
</I>&gt;&gt;<i> DEG_2, DEG_3, DEG_4 };
</I>&gt;<i> //static long seps [MAX_TYPES] = { SEP_0, SEP_1,
</I>&gt;&gt;<i> SEP_2, SEP_3, SEP_4 };
</I>&gt;<i>
</I>&gt;<i> degrees[0] = DEG_0;
</I>&gt;<i> degrees[1] = DEG_1;
</I>&gt;&gt;<i> degrees[2] = DEG_2;
</I>&gt;<i> degrees[3] = DEG_3;
</I>&gt;<i> degrees[4] = DEG_4;
</I>&gt;<i>
</I>&gt;<i> seps [0] =
</I>&gt;&gt;<i> SEP_0;
</I>&gt;<i> seps [1] = SEP_1;
</I>&gt;<i> seps [2] = SEP_2;
</I>&gt;<i> seps [3] = SEP_3;
</I>&gt;<i> seps [4] =
</I>&gt;&gt;<i> SEP_4;
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // Initially, everything is set up as if from:
</I>&gt;<i> //
</I>&gt;<i> // initstate(1,
</I>&gt;&gt;<i> randtbl, 128);
</I>&gt;<i> //
</I>&gt;<i> // Note that this initialization takes advantage of the
</I>&gt;&gt;<i> fact that srandom()
</I>&gt;<i> // advances the front and rear pointers 10*rand_deg
</I>&gt;&gt;<i> times, and hence the
</I>&gt;<i> // rear pointer which starts at 0 will also end up at
</I>&gt;&gt;<i> zero; thus the zeroeth
</I>&gt;<i> // element of the state information, which contains
</I>&gt;&gt;<i> info about the current
</I>&gt;<i> // position of the rear pointer is just
</I>&gt;<i> //
</I>&gt;<i> //
</I>&gt;&gt;<i> MAX_TYPES * (rptr - state) + TYPE_3 == TYPE_3.
</I>&gt;<i>
</I>&gt;<i> randtbl[ 0] = TYPE_3;
</I>&gt;&gt;<i> randtbl[ 1] = 0x991539b1;
</I>&gt;<i> randtbl[ 2] = 0x16a5bce3;
</I>&gt;<i> randtbl[ 3] =
</I>&gt;&gt;<i> 0x6774a4cd;
</I>&gt;<i> randtbl[ 4] = 0x3e01511e;
</I>&gt;<i> randtbl[ 5] = 0x4e508aaa;
</I>&gt;<i> randtbl[
</I>&gt;&gt;<i> 6] = 0x61048c05;
</I>&gt;<i> randtbl[ 7] = 0xf5500617;
</I>&gt;<i> randtbl[ 8] = 0x846b7115;
</I>&gt;&gt;<i> randtbl[ 9] = 0x6a19892c;
</I>&gt;<i> randtbl[10] = 0x896a97af;
</I>&gt;<i> randtbl[11] =
</I>&gt;&gt;<i> 0xdb48f936;
</I>&gt;<i> randtbl[12] = 0x14898454;
</I>&gt;<i> randtbl[13] = 0x37ffd106;
</I>&gt;&gt;<i> randtbl[14] = 0xb58bff9c;
</I>&gt;<i> randtbl[15] = 0x59e17104;
</I>&gt;<i> randtbl[16] =
</I>&gt;&gt;<i> 0xcf918a49;
</I>&gt;<i> randtbl[17] = 0x09378c83;
</I>&gt;<i> randtbl[18] = 0x52c7a471;
</I>&gt;&gt;<i> randtbl[19] = 0x8d293ea9;
</I>&gt;<i> randtbl[20] = 0x1f4fc301;
</I>&gt;<i> randtbl[21] =
</I>&gt;&gt;<i> 0xc3db71be;
</I>&gt;<i> randtbl[22] = 0x39b44e1c;
</I>&gt;<i> randtbl[23] = 0xf8a44ef9;
</I>&gt;&gt;<i> randtbl[24] = 0x4c8b80b1;
</I>&gt;<i> randtbl[25] = 0x19edc328;
</I>&gt;<i> randtbl[26] =
</I>&gt;&gt;<i> 0x87bf4bdd;
</I>&gt;<i> randtbl[27] = 0xc9b240e5;
</I>&gt;<i> randtbl[28] = 0xe9ee4b1b;
</I>&gt;&gt;<i> randtbl[29] = 0x4382aee7;
</I>&gt;<i> randtbl[30] = 0x535b6b41;
</I>&gt;<i> randtbl[31] =
</I>&gt;&gt;<i> 0xf3bec5da;
</I>&gt;<i>
</I>&gt;<i> // static long randtbl[DEG_3 + 1] =
</I>&gt;<i> // {
</I>&gt;<i> // TYPE_3;
</I>&gt;<i> //
</I>&gt;&gt;<i> 0x991539b1, 0x16a5bce3, 0x6774a4cd, 0x3e01511e, 0x4e508aaa, 0x61048c05,
</I>&gt;<i> //
</I>&gt;&gt;<i> 0xf5500617, 0x846b7115, 0x6a19892c, 0x896a97af, 0xdb48f936, 0x14898454,
</I>&gt;<i> //
</I>&gt;&gt;<i> 0x37ffd106, 0xb58bff9c, 0x59e17104, 0xcf918a49, 0x09378c83, 0x52c7a471,
</I>&gt;<i> //
</I>&gt;&gt;<i> 0x8d293ea9, 0x1f4fc301, 0xc3db71be, 0x39b44e1c, 0xf8a44ef9, 0x4c8b80b1,
</I>&gt;<i> //
</I>&gt;&gt;<i> 0x19edc328, 0x87bf4bdd, 0xc9b240e5, 0xe9ee4b1b, 0x4382aee7, 0x535b6b41,
</I>&gt;<i> //
</I>&gt;&gt;<i> 0xf3bec5da
</I>&gt;<i> // };
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // fptr and rptr are two pointers into the state info,
</I>&gt;&gt;<i> a front and a rear
</I>&gt;<i> // pointer. These two pointers are always rand_sep places
</I>&gt;&gt;<i> aparts, as they
</I>&gt;<i> // cycle cyclically through the state information. (Yes,
</I>&gt;&gt;<i> this does mean we
</I>&gt;<i> // could get away with just one pointer, but the code for
</I>&gt;&gt;<i> random() is more
</I>&gt;<i> // efficient this way). The pointers are left positioned as
</I>&gt;&gt;<i> they would be
</I>&gt;<i> // from the call
</I>&gt;<i> //
</I>&gt;<i> // initstate(1, randtbl, 128);
</I>&gt;<i> //
</I>&gt;<i> // (The
</I>&gt;&gt;<i> position of the rear pointer, rptr, is really 0 (as explained above
</I>&gt;<i> // in
</I>&gt;&gt;<i> the initialization of randtbl) because the state table pointer is set
</I>&gt;<i> // to
</I>&gt;&gt;<i> point to randtbl[1] (as explained below).
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> fptr = &amp;randtbl[SEP_3 + 1];
</I>&gt;&gt;<i> rptr = &amp;randtbl[1];
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // The following things are the pointer to the state
</I>&gt;&gt;<i> information table, the
</I>&gt;<i> // type of the current generator, the degree of the
</I>&gt;&gt;<i> current polynomial being
</I>&gt;<i> // used, and the separation between the two
</I>&gt;&gt;<i> pointers. Note that for efficiency
</I>&gt;<i> // of random(), we remember the first
</I>&gt;&gt;<i> location of the state information, not
</I>&gt;<i> // the zeroeth. Hence it is valid to
</I>&gt;&gt;<i> access state[-1], which is used to
</I>&gt;<i> // store the type of the R.N.G. Also, we
</I>&gt;&gt;<i> remember the last location, since
</I>&gt;<i> // this is more efficient than indexing
</I>&gt;&gt;<i> every time to find the address of
</I>&gt;<i> // the last element to see if the front
</I>&gt;&gt;<i> and rear pointers have wrapped.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> state = &amp;randtbl[1];
</I>&gt;<i> rand_type =
</I>&gt;&gt;<i> TYPE_3;
</I>&gt;<i> rand_deg = DEG_3;
</I>&gt;<i> rand_sep = SEP_3;
</I>&gt;<i> end_ptr = &amp;randtbl[DEG_3 +
</I>&gt;&gt;<i> 1];
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // Compute x = (7^5 * x) mod (2^31 - 1)
</I>&gt;<i> // wihout overflowing 31
</I>&gt;&gt;<i> bits:
</I>&gt;<i> // (2^31 - 1) = 127773 * (7^5) + 2836
</I>&gt;<i> // From &quot;Random number
</I>&gt;&gt;<i> generators: good ones are hard to find&quot;,
</I>&gt;<i> // Park and Miller, Communications
</I>&gt;&gt;<i> of the ACM, vol. 31, no. 10,
</I>&gt;<i> // October 1988, p. 1195.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> __inline static
</I>&gt;&gt;<i> long good_rand(long x)
</I>&gt;<i> {
</I>&gt;<i> long hi, lo;
</I>&gt;<i>
</I>&gt;<i> // Can't be initialized with 0, so
</I>&gt;&gt;<i> use another value.
</I>&gt;<i> if (x == 0) x = 123459876;
</I>&gt;<i> hi = x / 127773;
</I>&gt;<i> lo = x %
</I>&gt;&gt;<i> 127773;
</I>&gt;<i> x = 16807 * lo - 2836 * hi;
</I>&gt;<i> if (x &lt; 0) x += 0x7fffffff;
</I>&gt;<i> return
</I>&gt;&gt;<i> x;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // srandom
</I>&gt;<i> //
</I>&gt;<i> // Initialize the random number generator based on
</I>&gt;&gt;<i> the given seed. If the
</I>&gt;<i> // type is the trivial no-state-information type,
</I>&gt;&gt;<i> just remember the seed.
</I>&gt;<i> // Otherwise, initializes state[] based on the given
</I>&gt;&gt;<i> &quot;seed&quot; via a linear
</I>&gt;<i> // congruential generator. Then, the pointers are set to
</I>&gt;&gt;<i> known locations
</I>&gt;<i> // that are exactly rand_sep places apart. Lastly, it cycles
</I>&gt;&gt;<i> the state
</I>&gt;<i> // information a given number of times to get rid of any initial
</I>&gt;&gt;<i> dependencies
</I>&gt;<i> // introduced by the L.C.R.N.G. Note that the initialization of
</I>&gt;&gt;<i> randtbl[]
</I>&gt;<i> // for default usage relies on values produced by this
</I>&gt;&gt;<i> routine.
</I>&gt;<i>
</I>&gt;<i> void RandomGenerator::srandom(unsigned long x)
</I>&gt;<i> {
</I>&gt;&gt;<i> long i, lim;
</I>&gt;<i>
</I>&gt;<i> state[0] = x;
</I>&gt;<i> if (rand_type == TYPE_0)
</I>&gt;<i> lim = NSHUFF;
</I>&gt;<i> else
</I>&gt;&gt;<i>
</I>&gt;<i> {
</I>&gt;<i> for (i = 1; i &lt; rand_deg; i++) state[i] = good_rand(state[i - 1]);
</I>&gt;&gt;<i> fptr = &amp;state[rand_sep];
</I>&gt;<i> rptr = &amp;state[0];
</I>&gt;<i> lim = 10 * rand_deg;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;&gt;<i> initialized = 1;
</I>&gt;<i> for (i = 0; i &lt; lim; i++) random();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> #ifdef
</I>&gt;&gt;<i> NOT_FOR_SUPERTUX // use in supertux doesn't require these methods,
</I>&gt;<i> // which
</I>&gt;&gt;<i> are not portable to as many platforms as
</I>&gt;<i> // SDL. The cost is that the
</I>&gt;&gt;<i> variability of the
</I>&gt;<i> // initial seed is reduced to only 32 bits of
</I>&gt;<i> //
</I>&gt;&gt;<i> randomness, seemingly enough. PAK 060420
</I>&gt;<i> //
</I>&gt;<i> // srandomdev
</I>&gt;<i> //
</I>&gt;<i> // Many
</I>&gt;&gt;<i> programs choose the seed value in a totally predictable manner.
</I>&gt;<i> // This
</I>&gt;&gt;<i> often causes problems. We seed the generator using the much more
</I>&gt;<i> // secure
</I>&gt;&gt;<i> random() interface. Note that this particular seeding
</I>&gt;<i> // procedure can
</I>&gt;&gt;<i> generate states which are impossible to reproduce by
</I>&gt;<i> // calling srandom()
</I>&gt;&gt;<i> with any value, since the succeeding terms in the
</I>&gt;<i> // state buffer are no
</I>&gt;&gt;<i> longer derived from the LC algorithm applied to
</I>&gt;<i> // a fixed seed.
</I>&gt;<i>
</I>&gt;<i> void
</I>&gt;&gt;<i> RandomGenerator::srandomdev()
</I>&gt;<i> {
</I>&gt;<i> int fd, done;
</I>&gt;<i> size_t len;
</I>&gt;<i>
</I>&gt;<i> if (rand_type
</I>&gt;&gt;<i> == TYPE_0)
</I>&gt;<i> len = sizeof state[0];
</I>&gt;<i> else
</I>&gt;<i> len = rand_deg * sizeof
</I>&gt;&gt;<i> state[0];
</I>&gt;<i>
</I>&gt;<i> done = 0;
</I>&gt;<i> fd = open(&quot;/dev/urandom&quot;, O_RDONLY);
</I>&gt;<i> if (fd &gt;= 0)
</I>&gt;&gt;<i> {
</I>&gt;<i> if (read(fd, state, len) == len) done = 1;
</I>&gt;<i> close(fd);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> if (!done)
</I>&gt;&gt;<i> {
</I>&gt;<i> struct timeval tv;
</I>&gt;<i>
</I>&gt;<i> gettimeofday(&amp;tv, NULL);
</I>&gt;<i> srandom(tv.tv_sec ^
</I>&gt;&gt;<i> tv.tv_usec);
</I>&gt;<i> return;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> if (rand_type != TYPE_0)
</I>&gt;<i> {
</I>&gt;<i> fptr =
</I>&gt;&gt;<i> &amp;state[rand_sep];
</I>&gt;<i> rptr = &amp;state[0];
</I>&gt;<i> }
</I>&gt;<i> initialized = 1;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> //
</I>&gt;&gt;<i> initstate
</I>&gt;<i> //
</I>&gt;<i> // Initialize the state information in the given array of n
</I>&gt;&gt;<i> bytes for future
</I>&gt;<i> // random number generation. Based on the number of bytes
</I>&gt;&gt;<i> we are given, and
</I>&gt;<i> // the break values for the different R.N.G.'s, we choose
</I>&gt;&gt;<i> the best (largest)
</I>&gt;<i> // one we can and set things up for it. srandom() is then
</I>&gt;&gt;<i> called to
</I>&gt;<i> // initialize the state information.
</I>&gt;<i> //
</I>&gt;<i> // Note that on return
</I>&gt;&gt;<i> from srandom(), we set state[-1] to be the type
</I>&gt;<i> // multiplexed with the
</I>&gt;&gt;<i> current value of the rear pointer; this is so
</I>&gt;<i> // successive calls to
</I>&gt;&gt;<i> initstate() won't lose this information and will be
</I>&gt;<i> // able to restart with
</I>&gt;&gt;<i> setstate().
</I>&gt;<i> //
</I>&gt;<i> // Note: the first thing we do is save the current state, if
</I>&gt;&gt;<i> any, just like
</I>&gt;<i> // setstate() so that it doesn't matter when initstate is
</I>&gt;&gt;<i> called.
</I>&gt;<i> //
</I>&gt;<i> // Returns a pointer to the old state.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> char *
</I>&gt;&gt;<i> RandomGenerator::initstate(unsigned long seed, char
</I>&gt;&gt;<i> *arg_state, long n)
</I>&gt;<i> {
</I>&gt;<i> char *ostate = (char *) (&amp;state[-1]);
</I>&gt;<i> long
</I>&gt;&gt;<i> *long_arg_state = (long *) arg_state;
</I>&gt;<i>
</I>&gt;<i> if (rand_type == TYPE_0)
</I>&gt;<i> state[-1]
</I>&gt;&gt;<i> = rand_type;
</I>&gt;<i> else
</I>&gt;<i> state[-1] = MAX_TYPES * (rptr - state) + rand_type;
</I>&gt;<i>
</I>&gt;<i> if
</I>&gt;&gt;<i> (n &lt; BREAK_0) return NULL;
</I>&gt;<i>
</I>&gt;<i> if (n &lt; BREAK_1)
</I>&gt;<i> {
</I>&gt;<i> rand_type = TYPE_0;
</I>&gt;&gt;<i> rand_deg = DEG_0;
</I>&gt;<i> rand_sep = SEP_0;
</I>&gt;<i> }
</I>&gt;<i> else if (n &lt; BREAK_2)
</I>&gt;<i> {
</I>&gt;&gt;<i> rand_type = TYPE_1;
</I>&gt;<i> rand_deg = DEG_1;
</I>&gt;<i> rand_sep = SEP_1;
</I>&gt;<i> }
</I>&gt;<i> else if (n &lt;
</I>&gt;&gt;<i> BREAK_3)
</I>&gt;<i> {
</I>&gt;<i> rand_type = TYPE_2;
</I>&gt;<i> rand_deg = DEG_2;
</I>&gt;<i> rand_sep = SEP_2;
</I>&gt;<i> }
</I>&gt;&gt;<i> else if (n &lt; BREAK_4)
</I>&gt;<i> {
</I>&gt;<i> rand_type = TYPE_3;
</I>&gt;<i> rand_deg = DEG_3;
</I>&gt;<i> rand_sep
</I>&gt;&gt;<i> = SEP_3;
</I>&gt;<i> }
</I>&gt;<i> else
</I>&gt;<i> {
</I>&gt;<i> rand_type = TYPE_4;
</I>&gt;<i> rand_deg = DEG_4;
</I>&gt;<i> rand_sep =
</I>&gt;&gt;<i> SEP_4;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> state = (long *) (long_arg_state + 1); // First location
</I>&gt;&gt;<i> end_ptr = &amp;state[rand_deg]; // Must set end_ptr before srandom
</I>&gt;&gt;<i> srandom(seed);
</I>&gt;<i>
</I>&gt;<i> if (rand_type == TYPE_0)
</I>&gt;<i> long_arg_state[0] = rand_type;
</I>&gt;&gt;<i> else
</I>&gt;<i> long_arg_state[0] = MAX_TYPES * (rptr - state) + rand_type;
</I>&gt;<i>
</I>&gt;&gt;<i> initialized = 1;
</I>&gt;<i> return ostate;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // setstate
</I>&gt;<i> //
</I>&gt;<i> // Restore the state
</I>&gt;&gt;<i> from the given state array.
</I>&gt;<i> //
</I>&gt;<i> // Note: it is important that we also
</I>&gt;&gt;<i> remember the locations of the pointers
</I>&gt;<i> // in the current state information,
</I>&gt;&gt;<i> and restore the locations of the pointers
</I>&gt;<i> // from the old state information.
</I>&gt;&gt;<i> This is done by multiplexing the pointer
</I>&gt;<i> // location into the zeroeth word
</I>&gt;&gt;<i> of the state information.
</I>&gt;<i> //
</I>&gt;<i> // Note that due to the order in which things
</I>&gt;&gt;<i> are done, it is OK to call
</I>&gt;<i> // setstate() with the same state as the current
</I>&gt;&gt;<i> state.
</I>&gt;<i> //
</I>&gt;<i> // Returns a pointer to the old state information.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> char *
</I>&gt;&gt;<i> RandomGenerator::setstate(char *arg_state)
</I>&gt;<i> {
</I>&gt;<i> long *new_state = (long *)
</I>&gt;&gt;<i> arg_state;
</I>&gt;<i> long type = new_state[0] % MAX_TYPES;
</I>&gt;<i> long rear = new_state[0]
</I>&gt;&gt;<i> / MAX_TYPES;
</I>&gt;<i> char *ostate = (char *) (&amp;state[-1]);
</I>&gt;<i>
</I>&gt;<i> if (rand_type ==
</I>&gt;&gt;<i> TYPE_0)
</I>&gt;<i> state[-1] = rand_type;
</I>&gt;<i> else
</I>&gt;<i> state[-1] = MAX_TYPES * (rptr -
</I>&gt;&gt;<i> state) + rand_type;
</I>&gt;<i>
</I>&gt;<i> switch(type)
</I>&gt;<i> {
</I>&gt;<i> case TYPE_0:
</I>&gt;<i> case TYPE_1:
</I>&gt;<i> case
</I>&gt;&gt;<i> TYPE_2:
</I>&gt;<i> case TYPE_3:
</I>&gt;<i> case TYPE_4:
</I>&gt;<i> rand_type = type;
</I>&gt;<i> rand_deg =
</I>&gt;&gt;<i> degrees[type];
</I>&gt;<i> rand_sep = seps[type];
</I>&gt;<i> break;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> state = (long *)
</I>&gt;&gt;<i> (new_state + 1);
</I>&gt;<i> if (rand_type != TYPE_0)
</I>&gt;<i> {
</I>&gt;<i> rptr = &amp;state[rear];
</I>&gt;<i> fptr =
</I>&gt;&gt;<i> &amp;state[(rear + rand_sep) % rand_deg];
</I>&gt;<i> }
</I>&gt;<i> end_ptr = &amp;state[rand_deg]; // Set
</I>&gt;&gt;<i> end_ptr too
</I>&gt;<i>
</I>&gt;<i> initialized = 1;
</I>&gt;<i> return ostate;
</I>&gt;<i> }
</I>&gt;<i> #endif
</I>&gt;&gt;<i> //NOT_FOR_SUPERTUX
</I>&gt;<i> //
</I>&gt;<i> // random:
</I>&gt;<i> //
</I>&gt;<i> // If we are using the trivial TYPE_0
</I>&gt;&gt;<i> R.N.G., just do the old linear
</I>&gt;<i> // congruential bit. Otherwise, we do our
</I>&gt;&gt;<i> fancy trinomial stuff, which is
</I>&gt;<i> // the same in all the other cases due to
</I>&gt;&gt;<i> all the global variables that have
</I>&gt;<i> // been set up. The basic operation is to
</I>&gt;&gt;<i> add the number at the rear pointer
</I>&gt;<i> // into the one at the front pointer.
</I>&gt;&gt;<i> Then both pointers are advanced to
</I>&gt;<i> // the next location cyclically in the
</I>&gt;&gt;<i> table. The value returned is the sum
</I>&gt;<i> // generated, reduced to 31 bits by
</I>&gt;&gt;<i> throwing away the &quot;least random&quot; low bit.
</I>&gt;<i> //
</I>&gt;<i> // Note: the code takes
</I>&gt;&gt;<i> advantage of the fact that both the front and
</I>&gt;<i> // rear pointers can't wrap on
</I>&gt;&gt;<i> the same call by not testing the rear
</I>&gt;<i> // pointer if the front one has
</I>&gt;&gt;<i> wrapped.
</I>&gt;<i> //
</I>&gt;<i> // Returns a 31-bit random number.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> long
</I>&gt;&gt;<i> RandomGenerator::random()
</I>&gt;<i> {
</I>&gt;<i> long i;
</I>&gt;<i> long *f, *r;
</I>&gt;<i> if (!initialized) {
</I>&gt;&gt;<i> throw std::runtime_error(&quot;uninitialized RandomGenerator
</I>&gt;&gt;<i> object&quot;);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> if (rand_type == TYPE_0)
</I>&gt;<i> {
</I>&gt;<i> i = state[0];
</I>&gt;<i> state[0] = i =
</I>&gt;&gt;<i> (good_rand(i)) &amp; 0x7fffffff;
</I>&gt;<i> }
</I>&gt;<i> else
</I>&gt;<i> {
</I>&gt;<i> f = fptr; r = rptr;
</I>&gt;<i> *f += *r;
</I>&gt;&gt;<i> i = (*f &gt;&gt; 1) &amp; 0x7fffffff; // Chucking least random bit
</I>&gt;<i> if (++f &gt;=
</I>&gt;&gt;<i> end_ptr)
</I>&gt;<i> {
</I>&gt;<i> f = state;
</I>&gt;<i> ++r;
</I>&gt;<i> }
</I>&gt;<i> else if (++r &gt;= end_ptr)
</I>&gt;<i> r = state;
</I>&gt;<i>
</I>&gt;&gt;<i> fptr = f; rptr = r;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> return i;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -- 
</I>&gt;<i> Flarbland: Your one and only stop for cheats, articles, comedy and
</I>&gt;<i> much, much more!
</I>&gt;<i> <A HREF="http://flarbland.bravehost.com">http://flarbland.bravehost.com</A>
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> [INFO] src/main.cpp:195 [C:\Documents and Settings\HP_Administrator\.supertux] is in the search path
</I>&gt;<i> [INFO] src/main.cpp:195 [c:\msys\1.0\build\supertux2\/data] is in the search path
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'controller' finished after 0.2 seconds
</I>&gt;<i> [WARNING] src/control/joystickkeyboardcontroller.cpp:192 Invalid button '0' in buttonmap
</I>&gt;<i> [WARNING] src/control/joystickkeyboardcontroller.cpp:192 Invalid button '1' in buttonmap
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'config' finished after 0.003 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'tinygettext' finished after 0.001 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'commandline' finished after 0 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'audio' finished after 0.335 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'video' finished after 5.476 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'scripting' finished after 0.236 seconds
</I>&gt;<i> [DEBUG] src/tile_manager.cpp:47 Tiles loaded in 0.463 seconds
</I>&gt;<i> [INFO] src/main.cpp:429 Component 'resources' finished after 3.552 seconds
</I>&gt;<i> ==== srand(1146426740) (         0) RAND_MAX=7fff =====
</I>&gt;<i> ERROR: x=44551574, x0=0, RAND_MAX=7fff
</I>&gt;<i> Assertion failed: 0, file src/random_generator.cpp, line 77
</I>&gt;<i>
</I>&gt;<i> This application has requested the Runtime to terminate it in an unusual way.
</I>&gt;<i> Please contact the application's support team for more information.
</I>&gt;<i>   
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> // $Id: random_generator.cpp 3435 2006-04-26 02:13:42Z sik0fewl $
</I>&gt;<i> // 
</I>&gt;<i> // A strong random number generator
</I>&gt;<i> //
</I>&gt;<i> // Copyright (C) 2006 Allen King
</I>&gt;<i> // Copyright (C) 2002 Michael Ringgaard. All rights reserved.
</I>&gt;<i> // Copyright (C) 1983, 1993 The Regents of the University of California.
</I>&gt;<i> //
</I>&gt;<i> // Redistribution and use in source and binary forms, with or without
</I>&gt;<i> // modification, are permitted provided that the following conditions
</I>&gt;<i> // are met:
</I>&gt;<i> // 
</I>&gt;<i> // 1. Redistributions of source code must retain the above copyright 
</I>&gt;<i> //    notice, this list of conditions and the following disclaimer.  
</I>&gt;<i> // 2. Redistributions in binary form must reproduce the above copyright
</I>&gt;<i> //    notice, this list of conditions and the following disclaimer in the
</I>&gt;<i> //    documentation and/or other materials provided with the distribution.  
</I>&gt;<i> // 3. Neither the name of the project nor the names of its contributors
</I>&gt;<i> //    may be used to endorse or promote products derived from this software
</I>&gt;<i> //    without specific prior written permission. 
</I>&gt;<i> // 
</I>&gt;<i> // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</I>&gt;<i> // ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
</I>&gt;<i> // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
</I>&gt;<i> // ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
</I>&gt;<i> // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</I>&gt;<i> // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</I>&gt;<i> // OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</I>&gt;<i> // HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
</I>&gt;<i> // LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
</I>&gt;<i> // OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
</I>&gt;<i> // SUCH DAMAGE.
</I>&gt;<i>
</I>&gt;<i> // Transliterated into C++ Allen King 060417, from sources on
</I>&gt;<i> //          <A HREF="http://www.jbox.dk/sanos/source/lib/random.c.html">http://www.jbox.dk/sanos/source/lib/random.c.html</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> #include &lt;stdexcept&gt;
</I>&gt;<i> #include &lt;stdio.h&gt;
</I>&gt;<i> #include &quot;random_generator.hpp&quot;
</I>&gt;<i> #include &quot;scripting/squirrel_util.hpp&quot;
</I>&gt;<i>
</I>&gt;<i> RandomGenerator systemRandom;               // global random number generator
</I>&gt;<i>
</I>&gt;<i> RandomGenerator::RandomGenerator() {
</I>&gt;<i>     assert(sizeof(int) &gt;= 4);
</I>&gt;<i>     initialized = 0;
</I>&gt;<i>     initialize();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> RandomGenerator::~RandomGenerator() {
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> /*int RandomGenerator::srand(int x)    {
</I>&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;<i>     assert(x &lt; RAND_MAX);                   // only allow posative 31-bit seeds
</I>&gt;<i>     assert(sizeof(int) &gt;= 4);
</I>&gt;<i>     srandom(x);
</I>&gt;<i>     return x;                               // let caller know seed used
</I>&gt;<i> }*/
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::srand(int x)    {
</I>&gt;<i>     int x0 = x;
</I>&gt;<i>     while (x == 0)                          // random seed of zero means
</I>&gt;<i>         x = time(0);                        // randomize with time
</I>&gt;<i>
</I>&gt;<i>     fprintf(stderr, &quot;==== srand(%10d) (%10d) RAND_MAX=%x =====\n&quot;, x, x0, RAND_MAX);
</I>&gt;<i>
</I>&gt;<i>     if (x &lt; RAND_MAX) {
</I>&gt;<i>     }
</I>&gt;<i>     else {                                  // only allow positive 31-bit seeds
</I>&gt;<i>
</I>&gt;<i>         fprintf(stderr, &quot;ERROR: x=%x, x0=%x, RAND_MAX=%x\n&quot;, x, x0, RAND_MAX);
</I>&gt;<i>
</I>&gt;<i>         assert(0);
</I>&gt;<i>     }
</I>&gt;<i>     RandomGenerator::srandom(x);
</I>&gt;<i>     return x;                               // let caller know seed used
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand()                 {        return random();    }
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand(int v) {
</I>&gt;<i>     assert(v != 0 &amp;&amp; v &lt;= RAND_MAX);        // illegal arg: 0 or too big
</I>&gt;<i>     return RandomGenerator::random() % v;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int RandomGenerator::rand(int u, int v) {
</I>&gt;<i>     assert(v &gt; u);    
</I>&gt;<i>     return u + RandomGenerator::rand(v-u);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> double RandomGenerator::randf(double v) {
</I>&gt;<i>     float rv;
</I>&gt;<i>     while ((rv = (double)RandomGenerator::random() / RAND_MAX * v) &gt;= v)
</I>&gt;<i>         ;                                   // never return v!
</I>&gt;<i>     return rv;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> double RandomGenerator::randf(double u, double v) {
</I>&gt;<i>     return u + RandomGenerator::randf(v-u);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //-----------------------------------------------------------------------
</I>&gt;<i> //        
</I>&gt;<i> // Copyright (C) 2002 Michael Ringgaard. All rights reserved.
</I>&gt;<i> // Copyright (C) 1983, 1993 The Regents of the University of California.
</I>&gt;<i> //
</I>&gt;<i> // Redistribution and use in source and binary forms, with or without
</I>&gt;<i> // modification, are permitted provided that the following conditions
</I>&gt;<i> // are met:
</I>&gt;<i> // 
</I>&gt;<i> // 1. Redistributions of source code must retain the above copyright 
</I>&gt;<i> //    notice, this list of conditions and the following disclaimer.  
</I>&gt;<i> // 2. Redistributions in binary form must reproduce the above copyright
</I>&gt;<i> //    notice, this list of conditions and the following disclaimer in the
</I>&gt;<i> //    documentation and/or other materials provided with the distribution.  
</I>&gt;<i> // 3. Neither the name of the project nor the names of its contributors
</I>&gt;<i> //    may be used to endorse or promote products derived from this software
</I>&gt;<i> //    without specific prior written permission. 
</I>&gt;<i> // 
</I>&gt;<i> // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</I>&gt;<i> // ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
</I>&gt;<i> // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
</I>&gt;<i> // ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
</I>&gt;<i> // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</I>&gt;<i> // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</I>&gt;<i> // OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</I>&gt;<i> // HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
</I>&gt;<i> // LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
</I>&gt;<i> // OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
</I>&gt;<i> // SUCH DAMAGE.
</I>&gt;<i> // 
</I>&gt;<i>
</I>&gt;<i> //**#include &lt;os.h&gt;
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // An improved random number generation package.  In addition to the standard
</I>&gt;<i> // rand()/srand() like interface, this package also has a special state info
</I>&gt;<i> // interface.  The initstate() routine is called with a seed, an array of
</I>&gt;<i> // bytes, and a count of how many bytes are being passed in; this array is
</I>&gt;<i> // then initialized to contain information for random number generation with
</I>&gt;<i> // that much state information.  Good sizes for the amount of state
</I>&gt;<i> // information are 32, 64, 128, and 256 bytes.  The state can be switched by
</I>&gt;<i> // calling the setstate() routine with the same array as was initiallized
</I>&gt;<i> // with initstate().  By default, the package runs with 128 bytes of state
</I>&gt;<i> // information and generates far better random numbers than a linear
</I>&gt;<i> // congruential generator.  If the amount of state information is less than
</I>&gt;<i> // 32 bytes, a simple linear congruential R.N.G. is used.
</I>&gt;<i> //
</I>&gt;<i> // Internally, the state information is treated as an array of longs; the
</I>&gt;<i> // zeroeth element of the array is the type of R.N.G. being used (small
</I>&gt;<i> // integer); the remainder of the array is the state information for the
</I>&gt;<i> // R.N.G.  Thus, 32 bytes of state information will give 7 longs worth of
</I>&gt;<i> // state information, which will allow a degree seven polynomial.  (Note:
</I>&gt;<i> // the zeroeth word of state information also has some other information
</I>&gt;<i> // stored in it -- see setstate() for details).
</I>&gt;<i> //
</I>&gt;<i> // The random number generation technique is a linear feedback shift register
</I>&gt;<i> // approach, employing trinomials (since there are fewer terms to sum up that
</I>&gt;<i> // way).  In this approach, the least significant bit of all the numbers in
</I>&gt;<i> // the state table will act as a linear feedback shift register, and will
</I>&gt;<i> // have period 2^deg - 1 (where deg is the degree of the polynomial being
</I>&gt;<i> // used, assuming that the polynomial is irreducible and primitive).  The
</I>&gt;<i> // higher order bits will have longer periods, since their values are also
</I>&gt;<i> // influenced by pseudo-random carries out of the lower bits.  The total
</I>&gt;<i> // period of the generator is approximately deg*(2**deg - 1); thus doubling
</I>&gt;<i> // the amount of state information has a vast influence on the period of the
</I>&gt;<i> // generator.  Note: the deg*(2**deg - 1) is an approximation only good for
</I>&gt;<i> // large deg, when the period of the shift is the dominant factor.
</I>&gt;<i> // With deg equal to seven, the period is actually much longer than the
</I>&gt;<i> // 7*(2**7 - 1) predicted by this formula.
</I>&gt;<i> //
</I>&gt;<i> // Modified 28 December 1994 by Jacob S. Rosenberg.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // For each of the currently supported random number generators, we have a
</I>&gt;<i> // break value on the amount of state information (you need at least this
</I>&gt;<i> // many bytes of state info to support this random number generator), a degree
</I>&gt;<i> // for the polynomial (actually a trinomial) that the R.N.G. is based on, and
</I>&gt;<i> // the separation between the two lower order coefficients of the trinomial.
</I>&gt;<i>
</I>&gt;<i> void RandomGenerator::initialize() {
</I>&gt;<i>
</I>&gt;<i> #define NSHUFF 100      // To drop part of seed -&gt; 1st value correlation
</I>&gt;<i>
</I>&gt;<i> //static long degrees[MAX_TYPES] = { DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 };
</I>&gt;<i> //static long seps [MAX_TYPES] = { SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 };
</I>&gt;<i>
</I>&gt;<i>     degrees[0] = DEG_0;
</I>&gt;<i>     degrees[1] = DEG_1;
</I>&gt;<i>     degrees[2] = DEG_2;
</I>&gt;<i>     degrees[3] = DEG_3;
</I>&gt;<i>     degrees[4] = DEG_4;
</I>&gt;<i>
</I>&gt;<i>     seps [0] = SEP_0;
</I>&gt;<i>     seps [1] = SEP_1;
</I>&gt;<i>     seps [2] = SEP_2;
</I>&gt;<i>     seps [3] = SEP_3;
</I>&gt;<i>     seps [4] = SEP_4;
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // Initially, everything is set up as if from:
</I>&gt;<i> //
</I>&gt;<i> //  initstate(1, randtbl, 128);
</I>&gt;<i> //
</I>&gt;<i> // Note that this initialization takes advantage of the fact that srandom()
</I>&gt;<i> // advances the front and rear pointers 10*rand_deg times, and hence the
</I>&gt;<i> // rear pointer which starts at 0 will also end up at zero; thus the zeroeth
</I>&gt;<i> // element of the state information, which contains info about the current
</I>&gt;<i> // position of the rear pointer is just
</I>&gt;<i> //
</I>&gt;<i> //  MAX_TYPES * (rptr - state) + TYPE_3 == TYPE_3.
</I>&gt;<i>
</I>&gt;<i>     randtbl[ 0] =  TYPE_3;
</I>&gt;<i>     randtbl[ 1] =  0x991539b1;
</I>&gt;<i>     randtbl[ 2] =  0x16a5bce3;
</I>&gt;<i>     randtbl[ 3] =  0x6774a4cd;
</I>&gt;<i>     randtbl[ 4] =  0x3e01511e;
</I>&gt;<i>     randtbl[ 5] =  0x4e508aaa;
</I>&gt;<i>     randtbl[ 6] =  0x61048c05;
</I>&gt;<i>     randtbl[ 7] =  0xf5500617;
</I>&gt;<i>     randtbl[ 8] =  0x846b7115;
</I>&gt;<i>     randtbl[ 9] =  0x6a19892c;
</I>&gt;<i>     randtbl[10] =  0x896a97af;
</I>&gt;<i>     randtbl[11] =  0xdb48f936;
</I>&gt;<i>     randtbl[12] =  0x14898454;
</I>&gt;<i>     randtbl[13] =  0x37ffd106;
</I>&gt;<i>     randtbl[14] =  0xb58bff9c;
</I>&gt;<i>     randtbl[15] =  0x59e17104;
</I>&gt;<i>     randtbl[16] =  0xcf918a49;
</I>&gt;<i>     randtbl[17] =  0x09378c83;
</I>&gt;<i>     randtbl[18] =  0x52c7a471;
</I>&gt;<i>     randtbl[19] =  0x8d293ea9;
</I>&gt;<i>     randtbl[20] =  0x1f4fc301;
</I>&gt;<i>     randtbl[21] =  0xc3db71be;
</I>&gt;<i>     randtbl[22] =  0x39b44e1c;
</I>&gt;<i>     randtbl[23] =  0xf8a44ef9;
</I>&gt;<i>     randtbl[24] =  0x4c8b80b1;
</I>&gt;<i>     randtbl[25] =  0x19edc328;
</I>&gt;<i>     randtbl[26] =  0x87bf4bdd;
</I>&gt;<i>     randtbl[27] =  0xc9b240e5;
</I>&gt;<i>     randtbl[28] =  0xe9ee4b1b;
</I>&gt;<i>     randtbl[29] =  0x4382aee7;
</I>&gt;<i>     randtbl[30] =  0x535b6b41;
</I>&gt;<i>     randtbl[31] =  0xf3bec5da;
</I>&gt;<i>
</I>&gt;<i> // static long randtbl[DEG_3 + 1] = 
</I>&gt;<i> // {
</I>&gt;<i> //   TYPE_3;
</I>&gt;<i> //   0x991539b1, 0x16a5bce3, 0x6774a4cd, 0x3e01511e, 0x4e508aaa, 0x61048c05,
</I>&gt;<i> //   0xf5500617, 0x846b7115, 0x6a19892c, 0x896a97af, 0xdb48f936, 0x14898454,
</I>&gt;<i> //   0x37ffd106, 0xb58bff9c, 0x59e17104, 0xcf918a49, 0x09378c83, 0x52c7a471,
</I>&gt;<i> //   0x8d293ea9, 0x1f4fc301, 0xc3db71be, 0x39b44e1c, 0xf8a44ef9, 0x4c8b80b1,
</I>&gt;<i> //   0x19edc328, 0x87bf4bdd, 0xc9b240e5, 0xe9ee4b1b, 0x4382aee7, 0x535b6b41,
</I>&gt;<i> //   0xf3bec5da
</I>&gt;<i> // };
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // fptr and rptr are two pointers into the state info, a front and a rear
</I>&gt;<i> // pointer.  These two pointers are always rand_sep places aparts, as they
</I>&gt;<i> // cycle cyclically through the state information.  (Yes, this does mean we
</I>&gt;<i> // could get away with just one pointer, but the code for random() is more
</I>&gt;<i> // efficient this way).  The pointers are left positioned as they would be
</I>&gt;<i> // from the call
</I>&gt;<i> //
</I>&gt;<i> //  initstate(1, randtbl, 128);
</I>&gt;<i> //
</I>&gt;<i> // (The position of the rear pointer, rptr, is really 0 (as explained above
</I>&gt;<i> // in the initialization of randtbl) because the state table pointer is set
</I>&gt;<i> // to point to randtbl[1] (as explained below).
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i>     fptr = &amp;randtbl[SEP_3 + 1];
</I>&gt;<i>     rptr = &amp;randtbl[1];
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // The following things are the pointer to the state information table, the
</I>&gt;<i> // type of the current generator, the degree of the current polynomial being
</I>&gt;<i> // used, and the separation between the two pointers.  Note that for efficiency
</I>&gt;<i> // of random(), we remember the first location of the state information, not
</I>&gt;<i> // the zeroeth.  Hence it is valid to access state[-1], which is used to
</I>&gt;<i> // store the type of the R.N.G.  Also, we remember the last location, since
</I>&gt;<i> // this is more efficient than indexing every time to find the address of
</I>&gt;<i> // the last element to see if the front and rear pointers have wrapped.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i>     state = &amp;randtbl[1];
</I>&gt;<i>     rand_type = TYPE_3;
</I>&gt;<i>     rand_deg = DEG_3;
</I>&gt;<i>     rand_sep = SEP_3;
</I>&gt;<i>     end_ptr = &amp;randtbl[DEG_3 + 1];
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // Compute x = (7^5 * x) mod (2^31 - 1)
</I>&gt;<i> // wihout overflowing 31 bits:
</I>&gt;<i> //      (2^31 - 1) = 127773 * (7^5) + 2836
</I>&gt;<i> // From &quot;Random number generators: good ones are hard to find&quot;,
</I>&gt;<i> // Park and Miller, Communications of the ACM, vol. 31, no. 10,
</I>&gt;<i> // October 1988, p. 1195.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> __inline static long good_rand(long x)
</I>&gt;<i> {
</I>&gt;<i>   long hi, lo;
</I>&gt;<i>
</I>&gt;<i>   // Can't be initialized with 0, so use another value.
</I>&gt;<i>   if (x == 0) x = 123459876;
</I>&gt;<i>   hi = x / 127773;
</I>&gt;<i>   lo = x % 127773;
</I>&gt;<i>   x = 16807 * lo - 2836 * hi;
</I>&gt;<i>   if (x &lt; 0) x += 0x7fffffff;
</I>&gt;<i>   return x;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // srandom
</I>&gt;<i> //
</I>&gt;<i> // Initialize the random number generator based on the given seed.  If the
</I>&gt;<i> // type is the trivial no-state-information type, just remember the seed.
</I>&gt;<i> // Otherwise, initializes state[] based on the given &quot;seed&quot; via a linear
</I>&gt;<i> // congruential generator.  Then, the pointers are set to known locations
</I>&gt;<i> // that are exactly rand_sep places apart.  Lastly, it cycles the state
</I>&gt;<i> // information a given number of times to get rid of any initial dependencies
</I>&gt;<i> // introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
</I>&gt;<i> // for default usage relies on values produced by this routine.
</I>&gt;<i>
</I>&gt;<i> void RandomGenerator::srandom(unsigned long x)
</I>&gt;<i> {
</I>&gt;<i>   long i, lim;
</I>&gt;<i>
</I>&gt;<i>   state[0] = x;
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     lim = NSHUFF;
</I>&gt;<i>   else 
</I>&gt;<i>   {
</I>&gt;<i>     for (i = 1; i &lt; rand_deg; i++) state[i] = good_rand(state[i - 1]);
</I>&gt;<i>     fptr = &amp;state[rand_sep];
</I>&gt;<i>     rptr = &amp;state[0];
</I>&gt;<i>     lim = 10 * rand_deg;
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   initialized = 1;
</I>&gt;<i>   for (i = 0; i &lt; lim; i++) random();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> #ifdef NOT_FOR_SUPERTUX     // use in supertux doesn't require these methods,
</I>&gt;<i>                             // which are not portable to as many platforms as
</I>&gt;<i>                             // SDL.  The cost is that the variability of the
</I>&gt;<i>                             // initial seed is reduced to only 32 bits of
</I>&gt;<i>                             // randomness, seemingly enough. PAK 060420
</I>&gt;<i> //
</I>&gt;<i> // srandomdev
</I>&gt;<i> //
</I>&gt;<i> // Many programs choose the seed value in a totally predictable manner.
</I>&gt;<i> // This often causes problems.  We seed the generator using the much more
</I>&gt;<i> // secure random() interface.  Note that this particular seeding
</I>&gt;<i> // procedure can generate states which are impossible to reproduce by
</I>&gt;<i> // calling srandom() with any value, since the succeeding terms in the
</I>&gt;<i> // state buffer are no longer derived from the LC algorithm applied to
</I>&gt;<i> // a fixed seed.
</I>&gt;<i>
</I>&gt;<i> void RandomGenerator::srandomdev()
</I>&gt;<i> {
</I>&gt;<i>   int fd, done;
</I>&gt;<i>   size_t len;
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     len = sizeof state[0];
</I>&gt;<i>   else
</I>&gt;<i>     len = rand_deg * sizeof state[0];
</I>&gt;<i>
</I>&gt;<i>   done = 0;
</I>&gt;<i>   fd = open(&quot;/dev/urandom&quot;, O_RDONLY);
</I>&gt;<i>   if (fd &gt;= 0) 
</I>&gt;<i>    {
</I>&gt;<i>      if (read(fd, state, len) == len) done = 1;
</I>&gt;<i>      close(fd);
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i>   if (!done) 
</I>&gt;<i>   {
</I>&gt;<i>     struct timeval tv;
</I>&gt;<i>
</I>&gt;<i>     gettimeofday(&amp;tv, NULL);
</I>&gt;<i>     srandom(tv.tv_sec ^ tv.tv_usec);
</I>&gt;<i>     return;
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   if (rand_type != TYPE_0) 
</I>&gt;<i>   {
</I>&gt;<i>     fptr = &amp;state[rand_sep];
</I>&gt;<i>     rptr = &amp;state[0];
</I>&gt;<i>   }
</I>&gt;<i>   initialized = 1;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // initstate
</I>&gt;<i> //
</I>&gt;<i> // Initialize the state information in the given array of n bytes for future
</I>&gt;<i> // random number generation.  Based on the number of bytes we are given, and
</I>&gt;<i> // the break values for the different R.N.G.'s, we choose the best (largest)
</I>&gt;<i> // one we can and set things up for it.  srandom() is then called to
</I>&gt;<i> // initialize the state information.
</I>&gt;<i> //
</I>&gt;<i> // Note that on return from srandom(), we set state[-1] to be the type
</I>&gt;<i> // multiplexed with the current value of the rear pointer; this is so
</I>&gt;<i> // successive calls to initstate() won't lose this information and will be
</I>&gt;<i> // able to restart with setstate().
</I>&gt;<i> //
</I>&gt;<i> // Note: the first thing we do is save the current state, if any, just like
</I>&gt;<i> // setstate() so that it doesn't matter when initstate is called.
</I>&gt;<i> //
</I>&gt;<i> // Returns a pointer to the old state.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> char * RandomGenerator::initstate(unsigned long seed, char *arg_state, long n)
</I>&gt;<i> {
</I>&gt;<i>   char *ostate = (char *) (&amp;state[-1]);
</I>&gt;<i>   long *long_arg_state = (long *) arg_state;
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     state[-1] = rand_type;
</I>&gt;<i>   else
</I>&gt;<i>     state[-1] = MAX_TYPES * (rptr - state) + rand_type;
</I>&gt;<i>
</I>&gt;<i>   if (n &lt; BREAK_0) return NULL;
</I>&gt;<i>
</I>&gt;<i>   if (n &lt; BREAK_1) 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_0;
</I>&gt;<i>     rand_deg = DEG_0;
</I>&gt;<i>     rand_sep = SEP_0;
</I>&gt;<i>   } 
</I>&gt;<i>   else if (n &lt; BREAK_2) 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_1;
</I>&gt;<i>     rand_deg = DEG_1;
</I>&gt;<i>     rand_sep = SEP_1;
</I>&gt;<i>   } 
</I>&gt;<i>   else if (n &lt; BREAK_3) 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_2;
</I>&gt;<i>     rand_deg = DEG_2;
</I>&gt;<i>     rand_sep = SEP_2;
</I>&gt;<i>   } 
</I>&gt;<i>   else if (n &lt; BREAK_4) 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_3;
</I>&gt;<i>     rand_deg = DEG_3;
</I>&gt;<i>     rand_sep = SEP_3;
</I>&gt;<i>   } 
</I>&gt;<i>   else 
</I>&gt;<i>   {
</I>&gt;<i>     rand_type = TYPE_4;
</I>&gt;<i>     rand_deg = DEG_4;
</I>&gt;<i>     rand_sep = SEP_4;
</I>&gt;<i>   }
</I>&gt;<i>   
</I>&gt;<i>   state = (long *) (long_arg_state + 1); // First location
</I>&gt;<i>   end_ptr = &amp;state[rand_deg]; // Must set end_ptr before srandom
</I>&gt;<i>   srandom(seed);
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     long_arg_state[0] = rand_type;
</I>&gt;<i>   else
</I>&gt;<i>     long_arg_state[0] = MAX_TYPES * (rptr - state) + rand_type;
</I>&gt;<i>
</I>&gt;<i>   initialized = 1;
</I>&gt;<i>   return ostate;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //
</I>&gt;<i> // setstate
</I>&gt;<i> //
</I>&gt;<i> // Restore the state from the given state array.
</I>&gt;<i> //
</I>&gt;<i> // Note: it is important that we also remember the locations of the pointers
</I>&gt;<i> // in the current state information, and restore the locations of the pointers
</I>&gt;<i> // from the old state information.  This is done by multiplexing the pointer
</I>&gt;<i> // location into the zeroeth word of the state information.
</I>&gt;<i> //
</I>&gt;<i> // Note that due to the order in which things are done, it is OK to call
</I>&gt;<i> // setstate() with the same state as the current state.
</I>&gt;<i> //
</I>&gt;<i> // Returns a pointer to the old state information.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> char * RandomGenerator::setstate(char *arg_state)
</I>&gt;<i> {
</I>&gt;<i>   long *new_state = (long *) arg_state;
</I>&gt;<i>   long type = new_state[0] % MAX_TYPES;
</I>&gt;<i>   long rear = new_state[0] / MAX_TYPES;
</I>&gt;<i>   char *ostate = (char *) (&amp;state[-1]);
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0)
</I>&gt;<i>     state[-1] = rand_type;
</I>&gt;<i>   else
</I>&gt;<i>     state[-1] = MAX_TYPES * (rptr - state) + rand_type;
</I>&gt;<i>
</I>&gt;<i>   switch(type) 
</I>&gt;<i>   {
</I>&gt;<i>     case TYPE_0:
</I>&gt;<i>     case TYPE_1:
</I>&gt;<i>     case TYPE_2:
</I>&gt;<i>     case TYPE_3:
</I>&gt;<i>     case TYPE_4:
</I>&gt;<i>       rand_type = type;
</I>&gt;<i>       rand_deg = degrees[type];
</I>&gt;<i>       rand_sep = seps[type];
</I>&gt;<i>       break;
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   state = (long *) (new_state + 1);
</I>&gt;<i>   if (rand_type != TYPE_0) 
</I>&gt;<i>   {
</I>&gt;<i>     rptr = &amp;state[rear];
</I>&gt;<i>     fptr = &amp;state[(rear + rand_sep) % rand_deg];
</I>&gt;<i>   }
</I>&gt;<i>   end_ptr = &amp;state[rand_deg];   // Set end_ptr too
</I>&gt;<i>
</I>&gt;<i>   initialized = 1;
</I>&gt;<i>   return ostate;
</I>&gt;<i> }
</I>&gt;<i> #endif //NOT_FOR_SUPERTUX
</I>&gt;<i> //
</I>&gt;<i> // random:
</I>&gt;<i> //
</I>&gt;<i> // If we are using the trivial TYPE_0 R.N.G., just do the old linear
</I>&gt;<i> // congruential bit.  Otherwise, we do our fancy trinomial stuff, which is
</I>&gt;<i> // the same in all the other cases due to all the global variables that have
</I>&gt;<i> // been set up.  The basic operation is to add the number at the rear pointer
</I>&gt;<i> // into the one at the front pointer.  Then both pointers are advanced to
</I>&gt;<i> // the next location cyclically in the table.  The value returned is the sum
</I>&gt;<i> // generated, reduced to 31 bits by throwing away the &quot;least random&quot; low bit.
</I>&gt;<i> //
</I>&gt;<i> // Note: the code takes advantage of the fact that both the front and
</I>&gt;<i> // rear pointers can't wrap on the same call by not testing the rear
</I>&gt;<i> // pointer if the front one has wrapped.
</I>&gt;<i> //
</I>&gt;<i> // Returns a 31-bit random number.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i> long RandomGenerator::random()
</I>&gt;<i> {
</I>&gt;<i>   long i;
</I>&gt;<i>   long *f, *r;
</I>&gt;<i>   if (!initialized) {
</I>&gt;<i>       throw std::runtime_error(&quot;uninitialized RandomGenerator object&quot;);
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   if (rand_type == TYPE_0) 
</I>&gt;<i>   {
</I>&gt;<i>     i = state[0];
</I>&gt;<i>     state[0] = i = (good_rand(i)) &amp; 0x7fffffff;
</I>&gt;<i>   } 
</I>&gt;<i>   else 
</I>&gt;<i>   {
</I>&gt;<i>     f = fptr; r = rptr;
</I>&gt;<i>     *f += *r;
</I>&gt;<i>     i = (*f &gt;&gt; 1) &amp; 0x7fffffff; // Chucking least random bit
</I>&gt;<i>     if (++f &gt;= end_ptr) 
</I>&gt;<i>     {
</I>&gt;<i>       f = state;
</I>&gt;<i>       ++r;
</I>&gt;<i>     }
</I>&gt;<i>     else if (++r &gt;= end_ptr) 
</I>&gt;<i>       r = state;
</I>&gt;<i>
</I>&gt;<i>     fptr = f; rptr = r;
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   return i;
</I>&gt;<i> }
</I>&gt;<i>   
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/supertux-devel/attachments/20060501/8d533885/attachment.html">https://lists.berlios.de/pipermail/supertux-devel/attachments/20060501/8d533885/attachment.html</A>&gt;
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: RandomGenerator.patch3b
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/supertux-devel/attachments/20060501/8d533885/attachment.ksh">https://lists.berlios.de/pipermail/supertux-devel/attachments/20060501/8d533885/attachment.ksh</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000189.html">[Supertux-devel] Infoboxes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#190">[ date ]</a>
              <a href="thread.html#190">[ thread ]</a>
              <a href="subject.html#190">[ subject ]</a>
              <a href="author.html#190">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/supertux-devel">More information about the Supertux-devel
mailing list</a><br>
</body></html>
